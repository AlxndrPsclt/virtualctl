{"mappings":"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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-16ae8cffac44c95a.js","src/app.js","node_modules/osc-js/lib/osc.min.js","node_modules/osc-js/src/common/utils.js","node_modules/osc-js/src/common/helpers.js","node_modules/osc-js/src/atomic.js","node_modules/osc-js/src/atomic/int32.js","node_modules/osc-js/src/atomic/string.js","node_modules/osc-js/src/atomic/timetag.js","node_modules/osc-js/src/atomic/blob.js","node_modules/osc-js/src/atomic/float32.js","node_modules/osc-js/src/atomic/float64.js","node_modules/osc-js/src/atomic/int64.js","node_modules/osc-js/src/atomic/uint64.js","node_modules/osc-js/src/atomic/constant.js","node_modules/osc-js/src/message.js","node_modules/osc-js/src/bundle.js","node_modules/osc-js/src/packet.js","node_modules/osc-js/src/events.js","node_modules/osc-js/src/plugin/plugin.js","node_modules/osc-js/src/plugin/dgram.js","node_modules/osc-js/src/external/ws.js","node_modules/osc-js/src/plugin/bridge.js","node_modules/osc-js/src/plugin/wsclient.js","node_modules/osc-js/src/plugin/wsserver.js","node_modules/osc-js/src/osc.js","node_modules/buffer/index.js","node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/@parcel/runtime-js/lib/runtime-4060a4294e388480.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = new Map();\nfunction $18c11f3350a906ea$var$register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)$18c11f3350a906ea$var$mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping.get(id);\n    if (resolved == null) throw new Error('Could not resolve bundle with id ' + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nvar $a6e846f41555afbc$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(new URL(\"\", import.meta.url).toString(), JSON.parse(\"[\\\"izUj7\\\",\\\"index.e121266c.js\\\",\\\"7yeQP\\\",\\\"sw.js\\\"]\"));\n\nvar $dddc8561b083d642$exports = {};\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ /* eslint-disable no-proto */ var $51861dfc7ca9d588$export$a143d493d941bafc;\nvar $51861dfc7ca9d588$export$e4cf37d7f6fb9e0a;\nvar $51861dfc7ca9d588$export$f99ded8fe4b79145;\nvar $51861dfc7ca9d588$export$599f31c3813fae4d;\n'use strict';\nvar $eeb0961446aae8e3$export$a48f0734ac7c2329;\nvar $eeb0961446aae8e3$export$d622b2ad8d90c771;\nvar $eeb0961446aae8e3$export$6100ba28696e12de;\n'use strict';\n$eeb0961446aae8e3$export$a48f0734ac7c2329 = $eeb0961446aae8e3$var$byteLength;\n$eeb0961446aae8e3$export$d622b2ad8d90c771 = $eeb0961446aae8e3$var$toByteArray;\n$eeb0961446aae8e3$export$6100ba28696e12de = $eeb0961446aae8e3$var$fromByteArray;\nvar $eeb0961446aae8e3$var$lookup = [];\nvar $eeb0961446aae8e3$var$revLookup = [];\nvar $eeb0961446aae8e3$var$Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar $eeb0961446aae8e3$var$code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor(var $eeb0961446aae8e3$var$i = 0, $eeb0961446aae8e3$var$len = $eeb0961446aae8e3$var$code.length; $eeb0961446aae8e3$var$i < $eeb0961446aae8e3$var$len; ++$eeb0961446aae8e3$var$i){\n    $eeb0961446aae8e3$var$lookup[$eeb0961446aae8e3$var$i] = $eeb0961446aae8e3$var$code[$eeb0961446aae8e3$var$i];\n    $eeb0961446aae8e3$var$revLookup[$eeb0961446aae8e3$var$code.charCodeAt($eeb0961446aae8e3$var$i)] = $eeb0961446aae8e3$var$i;\n}\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\n$eeb0961446aae8e3$var$revLookup['-'.charCodeAt(0)] = 62;\n$eeb0961446aae8e3$var$revLookup['_'.charCodeAt(0)] = 63;\nfunction $eeb0961446aae8e3$var$getLens(b64) {\n    var len = b64.length;\n    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');\n    // Trim off extra bytes after placeholder bytes are found\n    // See: https://github.com/beatgammit/base64-js/issues/42\n    var validLen = b64.indexOf('=');\n    if (validLen === -1) validLen = len;\n    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\n// base64 is 4/3 + up to two characters of the original data\nfunction $eeb0961446aae8e3$var$byteLength(b64) {\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen) {\n    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n}\nfunction $eeb0961446aae8e3$var$toByteArray(b64) {\n    var tmp;\n    var lens = $eeb0961446aae8e3$var$getLens(b64);\n    var validLen = lens[0];\n    var placeHoldersLen = lens[1];\n    var arr = new $eeb0961446aae8e3$var$Arr($eeb0961446aae8e3$var$_byteLength(b64, validLen, placeHoldersLen));\n    var curByte = 0;\n    // if there are placeholders, only get up to the last complete 4 chars\n    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n    var i;\n    for(i = 0; i < len; i += 4){\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 18 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 12 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] << 6 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 3)];\n        arr[curByte++] = tmp >> 16 & 0xFF;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 2) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 2 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] >> 4;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    if (placeHoldersLen === 1) {\n        tmp = $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i)] << 10 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 1)] << 4 | $eeb0961446aae8e3$var$revLookup[b64.charCodeAt(i + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 0xFF;\n        arr[curByte++] = tmp & 0xFF;\n    }\n    return arr;\n}\nfunction $eeb0961446aae8e3$var$tripletToBase64(num) {\n    return $eeb0961446aae8e3$var$lookup[num >> 18 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 12 & 0x3F] + $eeb0961446aae8e3$var$lookup[num >> 6 & 0x3F] + $eeb0961446aae8e3$var$lookup[num & 0x3F];\n}\nfunction $eeb0961446aae8e3$var$encodeChunk(uint8, start, end) {\n    var tmp;\n    var output = [];\n    for(var i = start; i < end; i += 3){\n        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n        output.push($eeb0961446aae8e3$var$tripletToBase64(tmp));\n    }\n    return output.join('');\n}\nfunction $eeb0961446aae8e3$var$fromByteArray(uint8) {\n    var tmp;\n    var len = uint8.length;\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n    ;\n    var parts = [];\n    var maxChunkLength = 16383 // must be multiple of 3\n    ;\n    // go through the array every three bytes, we'll deal with trailing stuff later\n    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push($eeb0961446aae8e3$var$encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n    // pad the end with zeros, but make sure to not forget the extra bytes\n    if (extraBytes === 1) {\n        tmp = uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 2] + $eeb0961446aae8e3$var$lookup[tmp << 4 & 0x3F] + '==');\n    } else if (extraBytes === 2) {\n        tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n        parts.push($eeb0961446aae8e3$var$lookup[tmp >> 10] + $eeb0961446aae8e3$var$lookup[tmp >> 4 & 0x3F] + $eeb0961446aae8e3$var$lookup[tmp << 2 & 0x3F] + '=');\n    }\n    return parts.join('');\n}\n\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ var $7221566bd4d49f44$export$aafa59e2e03f2942;\nvar $7221566bd4d49f44$export$68d8715fc104d294;\n$7221566bd4d49f44$export$aafa59e2e03f2942 = function(buffer, offset, isLE, mLen, nBytes) {\n    var e, m;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var nBits = -7;\n    var i = isLE ? nBytes - 1 : 0;\n    var d = isLE ? -1 : 1;\n    var s = buffer[offset + i];\n    i += d;\n    e = s & (1 << -nBits) - 1;\n    s >>= -nBits;\n    nBits += eLen;\n    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n    m = e & (1 << -nBits) - 1;\n    e >>= -nBits;\n    nBits += mLen;\n    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n    if (e === 0) e = 1 - eBias;\n    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;\n    else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n    }\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n$7221566bd4d49f44$export$68d8715fc104d294 = function(buffer, value, offset, isLE, mLen, nBytes) {\n    var e, m, c;\n    var eLen = nBytes * 8 - mLen - 1;\n    var eMax = (1 << eLen) - 1;\n    var eBias = eMax >> 1;\n    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n    var i = isLE ? 0 : nBytes - 1;\n    var d = isLE ? 1 : -1;\n    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n    } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n        }\n        if (e + eBias >= 1) value += rt / c;\n        else value += rt * Math.pow(2, 1 - eBias);\n        if (value * c >= 2) {\n            e++;\n            c /= 2;\n        }\n        if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n        } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n        } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n        }\n    }\n    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n    e = e << mLen | m;\n    eLen += mLen;\n    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n    buffer[offset + i - d] |= s * 128;\n};\n\n\nconst $51861dfc7ca9d588$var$customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation\n ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n : null;\n$51861dfc7ca9d588$export$a143d493d941bafc = $51861dfc7ca9d588$var$Buffer;\n$51861dfc7ca9d588$export$e4cf37d7f6fb9e0a = $51861dfc7ca9d588$var$SlowBuffer;\n$51861dfc7ca9d588$export$f99ded8fe4b79145 = 50;\nconst $51861dfc7ca9d588$var$K_MAX_LENGTH = 0x7fffffff;\n$51861dfc7ca9d588$export$599f31c3813fae4d = $51861dfc7ca9d588$var$K_MAX_LENGTH;\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */ $51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT = $51861dfc7ca9d588$var$typedArraySupport();\nif (!$51861dfc7ca9d588$var$Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\nfunction $51861dfc7ca9d588$var$typedArraySupport() {\n    // Can typed array instances can be augmented?\n    try {\n        const arr = new Uint8Array(1);\n        const proto = {\n            foo: function() {\n                return 42;\n            }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n    } catch (e) {\n        return false;\n    }\n}\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, 'parent', {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.buffer;\n    }\n});\nObject.defineProperty($51861dfc7ca9d588$var$Buffer.prototype, 'offset', {\n    enumerable: true,\n    get: function() {\n        if (!$51861dfc7ca9d588$var$Buffer.isBuffer(this)) return undefined;\n        return this.byteOffset;\n    }\n});\nfunction $51861dfc7ca9d588$var$createBuffer(length) {\n    if (length > $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n    // Return an augmented `Uint8Array` instance\n    const buf = new Uint8Array(length);\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */ function $51861dfc7ca9d588$var$Buffer(arg, encodingOrOffset, length) {\n    // Common case.\n    if (typeof arg === 'number') {\n        if (typeof encodingOrOffset === 'string') throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        return $51861dfc7ca9d588$var$allocUnsafe(arg);\n    }\n    return $51861dfc7ca9d588$var$from(arg, encodingOrOffset, length);\n}\n$51861dfc7ca9d588$var$Buffer.poolSize = 8192 // not used by this implementation\n;\nfunction $51861dfc7ca9d588$var$from(value, encodingOrOffset, length) {\n    if (typeof value === 'string') return $51861dfc7ca9d588$var$fromString(value, encodingOrOffset);\n    if (ArrayBuffer.isView(value)) return $51861dfc7ca9d588$var$fromArrayView(value);\n    if (value == null) throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    if ($51861dfc7ca9d588$var$isInstance(value, ArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, ArrayBuffer)) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof SharedArrayBuffer !== 'undefined' && ($51861dfc7ca9d588$var$isInstance(value, SharedArrayBuffer) || value && $51861dfc7ca9d588$var$isInstance(value.buffer, SharedArrayBuffer))) return $51861dfc7ca9d588$var$fromArrayBuffer(value, encodingOrOffset, length);\n    if (typeof value === 'number') throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null && valueOf !== value) return $51861dfc7ca9d588$var$Buffer.from(valueOf, encodingOrOffset, length);\n    const b = $51861dfc7ca9d588$var$fromObject(value);\n    if (b) return b;\n    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return $51861dfc7ca9d588$var$Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n}\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/ $51861dfc7ca9d588$var$Buffer.from = function(value, encodingOrOffset, length) {\n    return $51861dfc7ca9d588$var$from(value, encodingOrOffset, length);\n};\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer.prototype, Uint8Array.prototype);\nObject.setPrototypeOf($51861dfc7ca9d588$var$Buffer, Uint8Array);\nfunction $51861dfc7ca9d588$var$assertSize(size) {\n    if (typeof size !== 'number') throw new TypeError('\"size\" argument must be of type number');\n    else if (size < 0) throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n}\nfunction $51861dfc7ca9d588$var$alloc(size, fill, encoding) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    if (size <= 0) return $51861dfc7ca9d588$var$createBuffer(size);\n    if (fill !== undefined) // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string' ? $51861dfc7ca9d588$var$createBuffer(size).fill(fill, encoding) : $51861dfc7ca9d588$var$createBuffer(size).fill(fill);\n    return $51861dfc7ca9d588$var$createBuffer(size);\n}\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/ $51861dfc7ca9d588$var$Buffer.alloc = function(size, fill, encoding) {\n    return $51861dfc7ca9d588$var$alloc(size, fill, encoding);\n};\nfunction $51861dfc7ca9d588$var$allocUnsafe(size) {\n    $51861dfc7ca9d588$var$assertSize(size);\n    return $51861dfc7ca9d588$var$createBuffer(size < 0 ? 0 : $51861dfc7ca9d588$var$checked(size) | 0);\n}\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */ $51861dfc7ca9d588$var$Buffer.allocUnsafe = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */ $51861dfc7ca9d588$var$Buffer.allocUnsafeSlow = function(size) {\n    return $51861dfc7ca9d588$var$allocUnsafe(size);\n};\nfunction $51861dfc7ca9d588$var$fromString(string, encoding) {\n    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';\n    if (!$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n    const length = $51861dfc7ca9d588$var$byteLength(string, encoding) | 0;\n    let buf = $51861dfc7ca9d588$var$createBuffer(length);\n    const actual = buf.write(string, encoding);\n    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayLike(array) {\n    const length = array.length < 0 ? 0 : $51861dfc7ca9d588$var$checked(array.length) | 0;\n    const buf = $51861dfc7ca9d588$var$createBuffer(length);\n    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromArrayView(arrayView) {\n    if ($51861dfc7ca9d588$var$isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return $51861dfc7ca9d588$var$fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n    }\n    return $51861dfc7ca9d588$var$fromArrayLike(arrayView);\n}\nfunction $51861dfc7ca9d588$var$fromArrayBuffer(array, byteOffset, length) {\n    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('\"offset\" is outside of buffer bounds');\n    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('\"length\" is outside of buffer bounds');\n    let buf;\n    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);\n    else if (length === undefined) buf = new Uint8Array(array, byteOffset);\n    else buf = new Uint8Array(array, byteOffset, length);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(buf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return buf;\n}\nfunction $51861dfc7ca9d588$var$fromObject(obj) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(obj)) {\n        const len = $51861dfc7ca9d588$var$checked(obj.length) | 0;\n        const buf = $51861dfc7ca9d588$var$createBuffer(len);\n        if (buf.length === 0) return buf;\n        obj.copy(buf, 0, 0, len);\n        return buf;\n    }\n    if (obj.length !== undefined) {\n        if (typeof obj.length !== 'number' || $51861dfc7ca9d588$var$numberIsNaN(obj.length)) return $51861dfc7ca9d588$var$createBuffer(0);\n        return $51861dfc7ca9d588$var$fromArrayLike(obj);\n    }\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return $51861dfc7ca9d588$var$fromArrayLike(obj.data);\n}\nfunction $51861dfc7ca9d588$var$checked(length) {\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n    // length is NaN (which is otherwise coerced to zero.)\n    if (length >= $51861dfc7ca9d588$var$K_MAX_LENGTH) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + $51861dfc7ca9d588$var$K_MAX_LENGTH.toString(16) + ' bytes');\n    return length | 0;\n}\nfunction $51861dfc7ca9d588$var$SlowBuffer(length) {\n    if (+length != length) length = 0;\n    return $51861dfc7ca9d588$var$Buffer.alloc(+length);\n}\n$51861dfc7ca9d588$var$Buffer.isBuffer = function isBuffer(b) {\n    return b != null && b._isBuffer === true && b !== $51861dfc7ca9d588$var$Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n    ;\n};\n$51861dfc7ca9d588$var$Buffer.compare = function compare(a, b) {\n    if ($51861dfc7ca9d588$var$isInstance(a, Uint8Array)) a = $51861dfc7ca9d588$var$Buffer.from(a, a.offset, a.byteLength);\n    if ($51861dfc7ca9d588$var$isInstance(b, Uint8Array)) b = $51861dfc7ca9d588$var$Buffer.from(b, b.offset, b.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(a) || !$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n    if (a === b) return 0;\n    let x = a.length;\n    let y = b.length;\n    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {\n        x = a[i];\n        y = b[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n$51861dfc7ca9d588$var$Buffer.isEncoding = function isEncoding(encoding) {\n    switch(String(encoding).toLowerCase()){\n        case 'hex':\n        case 'utf8':\n        case 'utf-8':\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n        case 'base64':\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return true;\n        default:\n            return false;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.concat = function concat(list, length) {\n    if (!Array.isArray(list)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (list.length === 0) return $51861dfc7ca9d588$var$Buffer.alloc(0);\n    let i;\n    if (length === undefined) {\n        length = 0;\n        for(i = 0; i < list.length; ++i)length += list[i].length;\n    }\n    const buffer = $51861dfc7ca9d588$var$Buffer.allocUnsafe(length);\n    let pos = 0;\n    for(i = 0; i < list.length; ++i){\n        let buf = list[i];\n        if ($51861dfc7ca9d588$var$isInstance(buf, Uint8Array)) {\n            if (pos + buf.length > buffer.length) {\n                if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) buf = $51861dfc7ca9d588$var$Buffer.from(buf);\n                buf.copy(buffer, pos);\n            } else Uint8Array.prototype.set.call(buffer, buf, pos);\n        } else if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        else buf.copy(buffer, pos);\n        pos += buf.length;\n    }\n    return buffer;\n};\nfunction $51861dfc7ca9d588$var$byteLength(string, encoding) {\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(string)) return string.length;\n    if (ArrayBuffer.isView(string) || $51861dfc7ca9d588$var$isInstance(string, ArrayBuffer)) return string.byteLength;\n    if (typeof string !== 'string') throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);\n    const len = string.length;\n    const mustMatch = arguments.length > 2 && arguments[2] === true;\n    if (!mustMatch && len === 0) return 0;\n    // Use a for loop to avoid recursion\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return len;\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8ToBytes(string).length;\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return len * 2;\n        case 'hex':\n            return len >>> 1;\n        case 'base64':\n            return $51861dfc7ca9d588$var$base64ToBytes(string).length;\n        default:\n            if (loweredCase) return mustMatch ? -1 : $51861dfc7ca9d588$var$utf8ToBytes(string).length // assume utf8\n            ;\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n}\n$51861dfc7ca9d588$var$Buffer.byteLength = $51861dfc7ca9d588$var$byteLength;\nfunction $51861dfc7ca9d588$var$slowToString(encoding, start, end) {\n    let loweredCase = false;\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n    // property of a typed array.\n    // This behaves neither like String nor Uint8Array in that we set start/end\n    // to their upper/lower bounds if the value passed is out of range.\n    // undefined is handled specially as per ECMA-262 6th Edition,\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n    if (start === undefined || start < 0) start = 0;\n    // Return early if start > this.length. Done here to prevent potential uint32\n    // coercion fail below.\n    if (start > this.length) return '';\n    if (end === undefined || end > this.length) end = this.length;\n    if (end <= 0) return '';\n    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n    end >>>= 0;\n    start >>>= 0;\n    if (end <= start) return '';\n    if (!encoding) encoding = 'utf8';\n    while(true)switch(encoding){\n        case 'hex':\n            return $51861dfc7ca9d588$var$hexSlice(this, start, end);\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8Slice(this, start, end);\n        case 'ascii':\n            return $51861dfc7ca9d588$var$asciiSlice(this, start, end);\n        case 'latin1':\n        case 'binary':\n            return $51861dfc7ca9d588$var$latin1Slice(this, start, end);\n        case 'base64':\n            return $51861dfc7ca9d588$var$base64Slice(this, start, end);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $51861dfc7ca9d588$var$utf16leSlice(this, start, end);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = (encoding + '').toLowerCase();\n            loweredCase = true;\n    }\n}\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\n$51861dfc7ca9d588$var$Buffer.prototype._isBuffer = true;\nfunction $51861dfc7ca9d588$var$swap(b, n, m) {\n    const i = b[n];\n    b[n] = b[m];\n    b[m] = i;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.swap16 = function swap16() {\n    const len = this.length;\n    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');\n    for(let i = 0; i < len; i += 2)$51861dfc7ca9d588$var$swap(this, i, i + 1);\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap32 = function swap32() {\n    const len = this.length;\n    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');\n    for(let i = 0; i < len; i += 4){\n        $51861dfc7ca9d588$var$swap(this, i, i + 3);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 2);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.swap64 = function swap64() {\n    const len = this.length;\n    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');\n    for(let i = 0; i < len; i += 8){\n        $51861dfc7ca9d588$var$swap(this, i, i + 7);\n        $51861dfc7ca9d588$var$swap(this, i + 1, i + 6);\n        $51861dfc7ca9d588$var$swap(this, i + 2, i + 5);\n        $51861dfc7ca9d588$var$swap(this, i + 3, i + 4);\n    }\n    return this;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toString = function toString() {\n    const length = this.length;\n    if (length === 0) return '';\n    if (arguments.length === 0) return $51861dfc7ca9d588$var$utf8Slice(this, 0, length);\n    return $51861dfc7ca9d588$var$slowToString.apply(this, arguments);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toLocaleString = $51861dfc7ca9d588$var$Buffer.prototype.toString;\n$51861dfc7ca9d588$var$Buffer.prototype.equals = function equals(b) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n    if (this === b) return true;\n    return $51861dfc7ca9d588$var$Buffer.compare(this, b) === 0;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.inspect = function inspect() {\n    let str = '';\n    const max = $51861dfc7ca9d588$export$f99ded8fe4b79145;\n    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n    if (this.length > max) str += ' ... ';\n    return '<Buffer ' + str + '>';\n};\nif ($51861dfc7ca9d588$var$customInspectSymbol) $51861dfc7ca9d588$var$Buffer.prototype[$51861dfc7ca9d588$var$customInspectSymbol] = $51861dfc7ca9d588$var$Buffer.prototype.inspect;\n$51861dfc7ca9d588$var$Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n    if ($51861dfc7ca9d588$var$isInstance(target, Uint8Array)) target = $51861dfc7ca9d588$var$Buffer.from(target, target.offset, target.byteLength);\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n    if (start === undefined) start = 0;\n    if (end === undefined) end = target ? target.length : 0;\n    if (thisStart === undefined) thisStart = 0;\n    if (thisEnd === undefined) thisEnd = this.length;\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');\n    if (thisStart >= thisEnd && start >= end) return 0;\n    if (thisStart >= thisEnd) return -1;\n    if (start >= end) return 1;\n    start >>>= 0;\n    end >>>= 0;\n    thisStart >>>= 0;\n    thisEnd >>>= 0;\n    if (this === target) return 0;\n    let x = thisEnd - thisStart;\n    let y = end - start;\n    const len = Math.min(x, y);\n    const thisCopy = this.slice(thisStart, thisEnd);\n    const targetCopy = target.slice(start, end);\n    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {\n        x = thisCopy[i];\n        y = targetCopy[i];\n        break;\n    }\n    if (x < y) return -1;\n    if (y < x) return 1;\n    return 0;\n};\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction $51861dfc7ca9d588$var$bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n    // Empty buffer means no match\n    if (buffer.length === 0) return -1;\n    // Normalize byteOffset\n    if (typeof byteOffset === 'string') {\n        encoding = byteOffset;\n        byteOffset = 0;\n    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;\n    else if (byteOffset < -2147483648) byteOffset = -2147483648;\n    byteOffset = +byteOffset // Coerce to Number.\n    ;\n    if ($51861dfc7ca9d588$var$numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : buffer.length - 1;\n    // Normalize byteOffset: negative offsets start from the end of the buffer\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n    if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n    } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n    }\n    // Normalize val\n    if (typeof val === 'string') val = $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\n    if ($51861dfc7ca9d588$var$Buffer.isBuffer(val)) {\n        // Special case: looking for empty string/buffer always fails\n        if (val.length === 0) return -1;\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n    } else if (typeof val === 'number') {\n        val = val & 0xFF // Search for a byte value [0-255]\n        ;\n        if (typeof Uint8Array.prototype.indexOf === 'function') {\n            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n        }\n        return $51861dfc7ca9d588$var$arrayIndexOf(buffer, [\n            val\n        ], byteOffset, encoding, dir);\n    }\n    throw new TypeError('val must be string, number or Buffer');\n}\nfunction $51861dfc7ca9d588$var$arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n    let indexSize = 1;\n    let arrLength = arr.length;\n    let valLength = val.length;\n    if (encoding !== undefined) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n            if (arr.length < 2 || val.length < 2) return -1;\n            indexSize = 2;\n            arrLength /= 2;\n            valLength /= 2;\n            byteOffset /= 2;\n        }\n    }\n    function read(buf, i) {\n        if (indexSize === 1) return buf[i];\n        else return buf.readUInt16BE(i * indexSize);\n    }\n    let i;\n    if (dir) {\n        let foundIndex = -1;\n        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n        } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n        }\n    } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for(i = byteOffset; i >= 0; i--){\n            let found = true;\n            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {\n                found = false;\n                break;\n            }\n            if (found) return i;\n        }\n    }\n    return -1;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n    return this.indexOf(val, byteOffset, encoding) !== -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n    return $51861dfc7ca9d588$var$bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n};\nfunction $51861dfc7ca9d588$var$hexWrite(buf, string, offset, length) {\n    offset = Number(offset) || 0;\n    const remaining = buf.length - offset;\n    if (!length) length = remaining;\n    else {\n        length = Number(length);\n        if (length > remaining) length = remaining;\n    }\n    const strLen = string.length;\n    if (length > strLen / 2) length = strLen / 2;\n    let i;\n    for(i = 0; i < length; ++i){\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if ($51861dfc7ca9d588$var$numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n    }\n    return i;\n}\nfunction $51861dfc7ca9d588$var$utf8Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf8ToBytes(string, buf.length - offset), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$asciiWrite(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$asciiToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$base64Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$base64ToBytes(string), buf, offset, length);\n}\nfunction $51861dfc7ca9d588$var$ucs2Write(buf, string, offset, length) {\n    return $51861dfc7ca9d588$var$blitBuffer($51861dfc7ca9d588$var$utf16leToBytes(string, buf.length - offset), buf, offset, length);\n}\n$51861dfc7ca9d588$var$Buffer.prototype.write = function write(string, offset, length, encoding) {\n    // Buffer#write(string)\n    if (offset === undefined) {\n        encoding = 'utf8';\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, encoding)\n    } else if (length === undefined && typeof offset === 'string') {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n    // Buffer#write(string, offset[, length][, encoding])\n    } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n            length = length >>> 0;\n            if (encoding === undefined) encoding = 'utf8';\n        } else {\n            encoding = length;\n            length = undefined;\n        }\n    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n    const remaining = this.length - offset;\n    if (length === undefined || length > remaining) length = remaining;\n    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');\n    if (!encoding) encoding = 'utf8';\n    let loweredCase = false;\n    for(;;)switch(encoding){\n        case 'hex':\n            return $51861dfc7ca9d588$var$hexWrite(this, string, offset, length);\n        case 'utf8':\n        case 'utf-8':\n            return $51861dfc7ca9d588$var$utf8Write(this, string, offset, length);\n        case 'ascii':\n        case 'latin1':\n        case 'binary':\n            return $51861dfc7ca9d588$var$asciiWrite(this, string, offset, length);\n        case 'base64':\n            // Warning: maxLength not taken into account in base64Write\n            return $51861dfc7ca9d588$var$base64Write(this, string, offset, length);\n        case 'ucs2':\n        case 'ucs-2':\n        case 'utf16le':\n        case 'utf-16le':\n            return $51861dfc7ca9d588$var$ucs2Write(this, string, offset, length);\n        default:\n            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n            encoding = ('' + encoding).toLowerCase();\n            loweredCase = true;\n    }\n};\n$51861dfc7ca9d588$var$Buffer.prototype.toJSON = function toJSON() {\n    return {\n        type: 'Buffer',\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nfunction $51861dfc7ca9d588$var$base64Slice(buf, start, end) {\n    if (start === 0 && end === buf.length) return $eeb0961446aae8e3$export$6100ba28696e12de(buf);\n    else return $eeb0961446aae8e3$export$6100ba28696e12de(buf.slice(start, end));\n}\nfunction $51861dfc7ca9d588$var$utf8Slice(buf, start, end) {\n    end = Math.min(buf.length, end);\n    const res = [];\n    let i = start;\n    while(i < end){\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n            let secondByte, thirdByte, fourthByte, tempCodePoint;\n            switch(bytesPerSequence){\n                case 1:\n                    if (firstByte < 0x80) codePoint = firstByte;\n                    break;\n                case 2:\n                    secondByte = buf[i + 1];\n                    if ((secondByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;\n                    }\n                    break;\n                case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;\n                    }\n            }\n        }\n        if (codePoint === null) {\n            // we did not generate a valid codePoint so insert a\n            // replacement char (U+FFFD) and advance only 1 byte\n            codePoint = 0xFFFD;\n            bytesPerSequence = 1;\n        } else if (codePoint > 0xFFFF) {\n            // encode to utf16 (surrogate pair dance)\n            codePoint -= 0x10000;\n            res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n            codePoint = 0xDC00 | codePoint & 0x3FF;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n    }\n    return $51861dfc7ca9d588$var$decodeCodePointsArray(res);\n}\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH = 0x1000;\nfunction $51861dfc7ca9d588$var$decodeCodePointsArray(codePoints) {\n    const len = codePoints.length;\n    if (len <= $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n    ;\n    // Decode in chunks to avoid \"call stack size exceeded\".\n    let res = '';\n    let i = 0;\n    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += $51861dfc7ca9d588$var$MAX_ARGUMENTS_LENGTH));\n    return res;\n}\nfunction $51861dfc7ca9d588$var$asciiSlice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$latin1Slice(buf, start, end) {\n    let ret = '';\n    end = Math.min(buf.length, end);\n    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);\n    return ret;\n}\nfunction $51861dfc7ca9d588$var$hexSlice(buf, start, end) {\n    const len = buf.length;\n    if (!start || start < 0) start = 0;\n    if (!end || end < 0 || end > len) end = len;\n    let out = '';\n    for(let i = start; i < end; ++i)out += $51861dfc7ca9d588$var$hexSliceLookupTable[buf[i]];\n    return out;\n}\nfunction $51861dfc7ca9d588$var$utf16leSlice(buf, start, end) {\n    const bytes = buf.slice(start, end);\n    let res = '';\n    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n    return res;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.slice = function slice(start, end) {\n    const len = this.length;\n    start = ~~start;\n    end = end === undefined ? len : ~~end;\n    if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n    } else if (start > len) start = len;\n    if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n    } else if (end > len) end = len;\n    if (end < start) end = start;\n    const newBuf = this.subarray(start, end);\n    // Return an augmented `Uint8Array` instance\n    Object.setPrototypeOf(newBuf, $51861dfc7ca9d588$var$Buffer.prototype);\n    return newBuf;\n};\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */ function $51861dfc7ca9d588$var$checkOffset(offset, ext, length) {\n    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n}\n$51861dfc7ca9d588$var$Buffer.prototype.readUintLE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUintBE = $51861dfc7ca9d588$var$Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset + --byteLength];\n    let mul = 1;\n    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint8 = $51861dfc7ca9d588$var$Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    return this[offset];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] | this[offset + 1] << 8;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    return this[offset] << 8 | this[offset + 1];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n    return BigInt(lo) + (BigInt(hi) << BigInt(32));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigUInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;\n    return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let val = this[offset];\n    let mul = 1;\n    let i = 0;\n    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, byteLength, this.length);\n    let i = byteLength;\n    let mul = 1;\n    let val = this[offset + --i];\n    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;\n    mul *= 0x80;\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n    return val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 1, this.length);\n    if (!(this[offset] & 0x80)) return this[offset];\n    return (0xff - this[offset] + 1) * -1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset] | this[offset + 1] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 2, this.length);\n    const val = this[offset + 1] | this[offset] << 8;\n    return val & 0x8000 ? val | 0xFFFF0000 : val;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64LE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow\n    );\n    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function readBigInt64BE(offset) {\n    offset = offset >>> 0;\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    const first = this[offset];\n    const last = this[offset + 7];\n    if (first === undefined || last === undefined) $51861dfc7ca9d588$var$boundsError(offset, this.length - 8);\n    const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];\n    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);\n});\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 4, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 23, 4);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, true, 52, 8);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkOffset(offset, 8, this.length);\n    return $7221566bd4d49f44$export$aafa59e2e03f2942(this, offset, false, 52, 8);\n};\nfunction $51861dfc7ca9d588$var$checkInt(buf, value, offset, ext, max, min) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintLE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let mul = 1;\n    let i = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUintBE = $51861dfc7ca9d588$var$Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    byteLength = byteLength >>> 0;\n    if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, maxBytes, 0);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint8 = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0xff, 0);\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint16BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0xffff, 0);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32LE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeUint32BE = $51861dfc7ca9d588$var$Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0xffffffff, 0);\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\nfunction $51861dfc7ca9d588$var$wrtBigUInt64LE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    lo = lo >> 8;\n    buf[offset++] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    hi = hi >> 8;\n    buf[offset++] = hi;\n    return offset;\n}\nfunction $51861dfc7ca9d588$var$wrtBigUInt64BE(buf, value, offset, min, max) {\n    $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, 7);\n    let lo = Number(value & BigInt(0xffffffff));\n    buf[offset + 7] = lo;\n    lo = lo >> 8;\n    buf[offset + 6] = lo;\n    lo = lo >> 8;\n    buf[offset + 5] = lo;\n    lo = lo >> 8;\n    buf[offset + 4] = lo;\n    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n    buf[offset + 3] = hi;\n    hi = hi >> 8;\n    buf[offset + 2] = hi;\n    hi = hi >> 8;\n    buf[offset + 1] = hi;\n    hi = hi >> 8;\n    buf[offset] = hi;\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigUInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = 0;\n    let mul = 1;\n    let sub = 0;\n    this[offset] = value & 0xFF;\n    while(++i < byteLength && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength - 1);\n        $51861dfc7ca9d588$var$checkInt(this, value, offset, byteLength, limit - 1, -limit);\n    }\n    let i = byteLength - 1;\n    let mul = 1;\n    let sub = 0;\n    this[offset + i] = value & 0xFF;\n    while(--i >= 0 && (mul *= 0x100)){\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;\n        this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n    }\n    return offset + byteLength;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 1, 0x7f, -128);\n    if (value < 0) value = 0xff + value + 1;\n    this[offset] = value & 0xff;\n    return offset + 1;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 2, 0x7fff, -32768);\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;\n    return offset + 2;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);\n    if (value < 0) value = 0xffffffff + value + 1;\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;\n    return offset + 4;\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64LE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\n$51861dfc7ca9d588$var$Buffer.prototype.writeBigInt64BE = $51861dfc7ca9d588$var$defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n    return $51861dfc7ca9d588$var$wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));\n});\nfunction $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, ext, max, min) {\n    if (offset + ext > buf.length) throw new RangeError('Index out of range');\n    if (offset < 0) throw new RangeError('Index out of range');\n}\nfunction $51861dfc7ca9d588$var$writeFloat(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 23, 4);\n    return offset + 4;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeFloat(this, value, offset, false, noAssert);\n};\nfunction $51861dfc7ca9d588$var$writeDouble(buf, value, offset, littleEndian, noAssert) {\n    value = +value;\n    offset = offset >>> 0;\n    if (!noAssert) $51861dfc7ca9d588$var$checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n    $7221566bd4d49f44$export$68d8715fc104d294(buf, value, offset, littleEndian, 52, 8);\n    return offset + 8;\n}\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, true, noAssert);\n};\n$51861dfc7ca9d588$var$Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n    return $51861dfc7ca9d588$var$writeDouble(this, value, offset, false, noAssert);\n};\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n$51861dfc7ca9d588$var$Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n    if (!$51861dfc7ca9d588$var$Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n    if (!start) start = 0;\n    if (!end && end !== 0) end = this.length;\n    if (targetStart >= target.length) targetStart = target.length;\n    if (!targetStart) targetStart = 0;\n    if (end > 0 && end < start) end = start;\n    // Copy 0 bytes; we're done\n    if (end === start) return 0;\n    if (target.length === 0 || this.length === 0) return 0;\n    // Fatal error conditions\n    if (targetStart < 0) throw new RangeError('targetStart out of bounds');\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n    if (end < 0) throw new RangeError('sourceEnd out of bounds');\n    // Are we oob?\n    if (end > this.length) end = this.length;\n    if (target.length - targetStart < end - start) end = target.length - targetStart + start;\n    const len = end - start;\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end);\n    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n    return len;\n};\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\n$51861dfc7ca9d588$var$Buffer.prototype.fill = function fill(val, start, end, encoding) {\n    // Handle string cases:\n    if (typeof val === 'string') {\n        if (typeof start === 'string') {\n            encoding = start;\n            start = 0;\n            end = this.length;\n        } else if (typeof end === 'string') {\n            encoding = end;\n            end = this.length;\n        }\n        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');\n        if (typeof encoding === 'string' && !$51861dfc7ca9d588$var$Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);\n        if (val.length === 1) {\n            const code = val.charCodeAt(0);\n            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.\n            val = code;\n        }\n    } else if (typeof val === 'number') val = val & 255;\n    else if (typeof val === 'boolean') val = Number(val);\n    // Invalid ranges are not set to a default, so can range check early.\n    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');\n    if (end <= start) return this;\n    start = start >>> 0;\n    end = end === undefined ? this.length : end >>> 0;\n    if (!val) val = 0;\n    let i;\n    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;\n    else {\n        const bytes = $51861dfc7ca9d588$var$Buffer.isBuffer(val) ? val : $51861dfc7ca9d588$var$Buffer.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];\n    }\n    return this;\n};\n// CUSTOM ERRORS\n// =============\n// Simplified versions from Node, changed for Buffer-only usage\nconst $51861dfc7ca9d588$var$errors = {};\nfunction $51861dfc7ca9d588$var$E(sym, getMessage, Base) {\n    $51861dfc7ca9d588$var$errors[sym] = class NodeError extends Base {\n        constructor(){\n            super();\n            Object.defineProperty(this, 'message', {\n                value: getMessage.apply(this, arguments),\n                writable: true,\n                configurable: true\n            });\n            // Add the error code to the name to include it in the stack trace.\n            this.name = `${this.name} [${sym}]`;\n            // Access the stack to generate the error message including the error code\n            // from the name.\n            this.stack // eslint-disable-line no-unused-expressions\n            ;\n            // Reset the name to the actual name.\n            delete this.name;\n        }\n        get code() {\n            return sym;\n        }\n        set code(value) {\n            Object.defineProperty(this, 'code', {\n                configurable: true,\n                enumerable: true,\n                value: value,\n                writable: true\n            });\n        }\n        toString() {\n            return `${this.name} [${sym}]: ${this.message}`;\n        }\n    };\n}\n$51861dfc7ca9d588$var$E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {\n    if (name) return `${name} is outside of buffer bounds`;\n    return 'Attempt to access memory outside buffer bounds';\n}, RangeError);\n$51861dfc7ca9d588$var$E('ERR_INVALID_ARG_TYPE', function(name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n}, TypeError);\n$51861dfc7ca9d588$var$E('ERR_OUT_OF_RANGE', function(str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`;\n    let received = input;\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = $51861dfc7ca9d588$var$addNumericalSeparator(String(input));\n    else if (typeof input === 'bigint') {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = $51861dfc7ca9d588$var$addNumericalSeparator(received);\n        received += 'n';\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n}, RangeError);\nfunction $51861dfc7ca9d588$var$addNumericalSeparator(val) {\n    let res = '';\n    let i = val.length;\n    const start = val[0] === '-' ? 1 : 0;\n    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;\n    return `${val.slice(0, i)}${res}`;\n}\n// CHECK FUNCTIONS\n// ===============\nfunction $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength) {\n    $51861dfc7ca9d588$var$validateNumber(offset, 'offset');\n    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) $51861dfc7ca9d588$var$boundsError(offset, buf.length - (byteLength + 1));\n}\nfunction $51861dfc7ca9d588$var$checkIntBI(value, min, max, buf, offset, byteLength) {\n    if (value > max || value < min) {\n        const n = typeof min === 'bigint' ? 'n' : '';\n        let range;\n        if (byteLength > 3) {\n            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;\n        } else range = `>= ${min}${n} and <= ${max}${n}`;\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE('value', range, value);\n    }\n    $51861dfc7ca9d588$var$checkBounds(buf, offset, byteLength);\n}\nfunction $51861dfc7ca9d588$var$validateNumber(value, name) {\n    if (typeof value !== 'number') throw new $51861dfc7ca9d588$var$errors.ERR_INVALID_ARG_TYPE(name, 'number', value);\n}\nfunction $51861dfc7ca9d588$var$boundsError(value, length, type) {\n    if (Math.floor(value) !== value) {\n        $51861dfc7ca9d588$var$validateNumber(value, type);\n        throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);\n    }\n    if (length < 0) throw new $51861dfc7ca9d588$var$errors.ERR_BUFFER_OUT_OF_BOUNDS();\n    throw new $51861dfc7ca9d588$var$errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);\n}\n// HELPER FUNCTIONS\n// ================\nconst $51861dfc7ca9d588$var$INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\nfunction $51861dfc7ca9d588$var$base64clean(str) {\n    // Node takes equal signs as end of the Base64 encoding\n    str = str.split('=')[0];\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n    str = str.trim().replace($51861dfc7ca9d588$var$INVALID_BASE64_RE, '');\n    // Node converts strings with length < 2 to ''\n    if (str.length < 2) return '';\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n    while(str.length % 4 !== 0)str = str + '=';\n    return str;\n}\nfunction $51861dfc7ca9d588$var$utf8ToBytes(string, units) {\n    units = units || Infinity;\n    let codePoint;\n    const length = string.length;\n    let leadSurrogate = null;\n    const bytes = [];\n    for(let i = 0; i < length; ++i){\n        codePoint = string.charCodeAt(i);\n        // is surrogate component\n        if (codePoint > 0xD7FF && codePoint < 0xE000) {\n            // last char was a lead\n            if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                }\n                // valid lead\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // 2 leads in a row\n            if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n            }\n            // valid surrogate pair\n            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n        } else if (leadSurrogate) // valid bmp char, but last char was a lead\n        {\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        }\n        leadSurrogate = null;\n        // encode utf8\n        if (codePoint < 0x80) {\n            if ((units -= 1) < 0) break;\n            bytes.push(codePoint);\n        } else if (codePoint < 0x800) {\n            if ((units -= 2) < 0) break;\n            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x10000) {\n            if ((units -= 3) < 0) break;\n            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else if (codePoint < 0x110000) {\n            if ((units -= 4) < 0) break;\n            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n        } else throw new Error('Invalid code point');\n    }\n    return bytes;\n}\nfunction $51861dfc7ca9d588$var$asciiToBytes(str) {\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF);\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$utf16leToBytes(str, units) {\n    let c, hi, lo;\n    const byteArray = [];\n    for(let i = 0; i < str.length; ++i){\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n    }\n    return byteArray;\n}\nfunction $51861dfc7ca9d588$var$base64ToBytes(str) {\n    return $eeb0961446aae8e3$export$d622b2ad8d90c771($51861dfc7ca9d588$var$base64clean(str));\n}\nfunction $51861dfc7ca9d588$var$blitBuffer(src, dst, offset, length) {\n    let i;\n    for(i = 0; i < length; ++i){\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n    }\n    return i;\n}\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction $51861dfc7ca9d588$var$isInstance(obj, type) {\n    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n}\nfunction $51861dfc7ca9d588$var$numberIsNaN(obj) {\n    // For IE11 support\n    return obj !== obj // eslint-disable-line no-self-compare\n    ;\n}\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst $51861dfc7ca9d588$var$hexSliceLookupTable = function() {\n    const alphabet = '0123456789abcdef';\n    const table = new Array(256);\n    for(let i = 0; i < 16; ++i){\n        const i16 = i * 16;\n        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];\n    }\n    return table;\n}();\n// Return not function with Error if BigInt not supported\nfunction $51861dfc7ca9d588$var$defineBigIntMethod(fn) {\n    return typeof BigInt === 'undefined' ? $51861dfc7ca9d588$var$BufferBigIntNotDefined : fn;\n}\nfunction $51861dfc7ca9d588$var$BufferBigIntNotDefined() {\n    throw new Error('BigInt not supported');\n}\n\n\nvar $dddc8561b083d642$require$Buffer = $51861dfc7ca9d588$export$a143d493d941bafc;\n!function(t, e) {\n    $dddc8561b083d642$exports = e();\n}($dddc8561b083d642$exports, function() {\n    \"use strict\";\n    function t(t, n, r) {\n        return n = f(n), function(t, e) {\n            if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n            if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n            return function(t) {\n                if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n                return t;\n            }(t);\n        }(t, e() ? Reflect.construct(n, r || [], f(t).constructor) : n.apply(t, r));\n    }\n    function e() {\n        try {\n            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        } catch (t) {}\n        return (e = function() {\n            return !!t;\n        })();\n    }\n    function n(t, e) {\n        var n = Object.keys(t);\n        if (Object.getOwnPropertySymbols) {\n            var r = Object.getOwnPropertySymbols(t);\n            e && (r = r.filter(function(e) {\n                return Object.getOwnPropertyDescriptor(t, e).enumerable;\n            })), n.push.apply(n, r);\n        }\n        return n;\n    }\n    function r(t) {\n        for(var e = 1; e < arguments.length; e++){\n            var r = null != arguments[e] ? arguments[e] : {};\n            e % 2 ? n(Object(r), !0).forEach(function(e) {\n                u(t, e, r[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach(function(e) {\n                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e));\n            });\n        }\n        return t;\n    }\n    function o(t) {\n        var e = function(t, e) {\n            if (\"object\" != typeof t || !t) return t;\n            var n = t[Symbol.toPrimitive];\n            if (void 0 !== n) {\n                var r = n.call(t, e || \"default\");\n                if (\"object\" != typeof r) return r;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (\"string\" === e ? String : Number)(t);\n        }(t, \"string\");\n        return \"symbol\" == typeof e ? e : e + \"\";\n    }\n    function i(t, e) {\n        if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function s(t, e) {\n        for(var n = 0; n < e.length; n++){\n            var r = e[n];\n            r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(t, o(r.key), r);\n        }\n    }\n    function a(t, e, n) {\n        return e && s(t.prototype, e), n && s(t, n), Object.defineProperty(t, \"prototype\", {\n            writable: !1\n        }), t;\n    }\n    function u(t, e, n) {\n        return (e = o(e)) in t ? Object.defineProperty(t, e, {\n            value: n,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : t[e] = n, t;\n    }\n    function c(t, e) {\n        if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n        t.prototype = Object.create(e && e.prototype, {\n            constructor: {\n                value: t,\n                writable: !0,\n                configurable: !0\n            }\n        }), Object.defineProperty(t, \"prototype\", {\n            writable: !1\n        }), e && l(t, e);\n    }\n    function f(t) {\n        return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {\n            return t.__proto__ || Object.getPrototypeOf(t);\n        }, f(t);\n    }\n    function l(t, e) {\n        return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {\n            return t.__proto__ = e, t;\n        }, l(t, e);\n    }\n    function h(t, e) {\n        for(; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t)););\n        return t;\n    }\n    function p() {\n        return p = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t, e, n) {\n            var r = h(t, e);\n            if (r) {\n                var o = Object.getOwnPropertyDescriptor(r, e);\n                return o.get ? o.get.call(arguments.length < 3 ? t : n) : o.value;\n            }\n        }, p.apply(this, arguments);\n    }\n    function d(t) {\n        return Number(t) === t && t % 1 == 0;\n    }\n    function v(t) {\n        return Number(t) === t;\n    }\n    function w(t) {\n        return \"string\" == typeof t;\n    }\n    function y(t) {\n        return \"boolean\" == typeof t;\n    }\n    function g(t) {\n        return t === 1 / 0;\n    }\n    function k(t) {\n        return \"[object Array]\" === Object.prototype.toString.call(t);\n    }\n    function b(t) {\n        return \"[object Object]\" === Object.prototype.toString.call(t);\n    }\n    function m(t) {\n        return \"function\" == typeof t;\n    }\n    function S(t) {\n        return t instanceof Uint8Array;\n    }\n    function E(t) {\n        return t instanceof Date;\n    }\n    function O(t) {\n        return void 0 === t;\n    }\n    function C(t) {\n        return null === t;\n    }\n    function P(t) {\n        return t + 3 & -4;\n    }\n    function A(t) {\n        return Object.prototype.hasOwnProperty.call(\"undefined\" != typeof $parcel$global ? $parcel$global : window, t);\n    }\n    function I(t) {\n        return t.buffer ? new DataView(t.buffer) : t instanceof ArrayBuffer ? new DataView(t) : new DataView(new Uint8Array(t));\n    }\n    function j(t) {\n        if (d(t)) return \"i\";\n        if (e = t, Number(e) === e && e % 1 != 0) return \"f\";\n        if (w(t)) return \"s\";\n        if (S(t)) return \"b\";\n        if (y(t)) return t ? \"T\" : \"F\";\n        if (C(t)) return \"N\";\n        if (g(t)) return \"I\";\n        var e;\n        throw new Error(\"OSC typeTag() found unknown value type\");\n    }\n    function D(t) {\n        var e = \"\";\n        if (k(t)) return \"/\".concat(t.join(\"/\"));\n        if (w(t)) return (e = t).length > 1 && \"/\" === e[e.length - 1] && (e = e.slice(0, e.length - 1)), e.length > 1 && \"/\" !== e[0] && (e = \"/\".concat(e)), e;\n        throw new Error(\"OSC prepareAddress() needs addresses of type array or string\");\n    }\n    function B(t) {\n        if (!w(t)) throw new Error(\"OSC prepareRegExPattern() needs strings\");\n        return t.replace(/\\./g, \"\\\\.\").replace(/\\(/g, \"\\\\(\").replace(/\\)/g, \"\\\\)\").replace(/\\{/g, \"(\").replace(/\\}/g, \")\").replace(/,/g, \"|\").replace(/\\[!/g, \"[^\").replace(/\\?/g, \".\").replace(/\\*/g, \".*\");\n    }\n    var M = a(function t() {\n        i(this, t), this.data = [], this.byteLength = 0;\n    }, [\n        {\n            key: \"add\",\n            value: function(t) {\n                if (y(t) || g(t) || C(t)) return this;\n                var e = t.pack();\n                return this.byteLength += e.byteLength, this.data.push(e), this;\n            }\n        },\n        {\n            key: \"merge\",\n            value: function() {\n                var t = new Uint8Array(this.byteLength), e = 0;\n                return this.data.forEach(function(n) {\n                    t.set(n, e), e += n.byteLength;\n                }), t;\n            }\n        }\n    ]), x = a(function t(e) {\n        i(this, t), this.value = e, this.offset = 0;\n    }, [\n        {\n            key: \"pack\",\n            value: function(t, e) {\n                if (!t || !e) throw new Error(\"OSC Atomic cant't be packed without given method or byteLength\");\n                var n = new Uint8Array(e), r = new DataView(n.buffer);\n                if (O(this.value)) throw new Error(\"OSC Atomic cant't be encoded with empty value\");\n                return r[t](this.offset, this.value, !1), n;\n            }\n        },\n        {\n            key: \"unpackWithMethod\",\n            value: function(t, e, n) {\n                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;\n                if (!(t && e && n)) throw new Error(\"OSC Atomic cant't be unpacked without given dataView, method or byteLength\");\n                if (!(t instanceof DataView)) throw new Error(\"OSC Atomic expects an instance of type DataView\");\n                return this.value = t[e](r, !1), this.offset = r + n, this.offset;\n            }\n        }\n    ]), T = function(e) {\n        function n(e) {\n            if (i(this, n), e && !d(e)) throw new Error(\"OSC AtomicInt32 constructor expects value of type number\");\n            return t(this, n, [\n                e\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    return p(f(n.prototype), \"pack\", this).call(this, \"setInt32\", 4);\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    return p(f(n.prototype), \"unpackWithMethod\", this).call(this, t, \"getInt32\", 4, e);\n                }\n            }\n        ]);\n    }(x), H = \"utf-8\";\n    function L(t) {\n        if (A(\"Buffer\")) return $dddc8561b083d642$require$Buffer.from(t).toString(H);\n        if (A(\"TextDecoder\")) return new TextDecoder(H).decode(new Int8Array(t));\n        for(var e = \"\", n = 0; n < t.length; n += 65537)e += String.fromCharCode.apply(null, t.slice(n, n + 65537));\n        return e;\n    }\n    var N = function(e) {\n        function n(e) {\n            if (i(this, n), e && !w(e)) throw new Error(\"OSC AtomicString constructor expects value of type string\");\n            return t(this, n, [\n                e\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    if (O(this.value)) throw new Error(\"OSC AtomicString can not be encoded with empty value\");\n                    for(var t = \"\".concat(this.value, \"\\0\"), e = P(t.length), n = new Uint8Array(e), r = 0; r < t.length; r += 1)n[r] = t.charCodeAt(r);\n                    return n;\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    if (!(t instanceof DataView)) throw new Error(\"OSC AtomicString expects an instance of type DataView\");\n                    for(var n, r = e, o = []; r < t.byteLength; r += 1){\n                        if (0 === (n = t.getUint8(r))) {\n                            r += 1;\n                            break;\n                        }\n                        o.push(n);\n                    }\n                    if (r === t.length) throw new Error(\"OSC AtomicString found a malformed OSC string\");\n                    return this.offset = P(r), this.value = L(o), this.offset;\n                }\n            }\n        ]);\n    }(x), V = 2208988800, W = 4294967296, U = a(function t() {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n        if (i(this, t), !d(e) || !d(n)) throw new Error(\"OSC Timetag constructor expects values of type integer number\");\n        this.seconds = e, this.fractions = n;\n    }, [\n        {\n            key: \"timestamp\",\n            value: function(t) {\n                var e;\n                if (\"number\" == typeof t) {\n                    e = t / 1e3;\n                    var n = Math.floor(e);\n                    return this.seconds = n + V, this.fractions = Math.round(W * (e - n)), t;\n                }\n                return 1e3 * ((e = this.seconds - V) + Math.round(this.fractions / W));\n            }\n        }\n    ]), _ = function(e) {\n        function n() {\n            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Date.now();\n            i(this, n);\n            var r = new U;\n            return e instanceof U ? r = e : d(e) ? r.timestamp(e) : E(e) && r.timestamp(e.getTime()), t(this, n, [\n                r\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    if (O(this.value)) throw new Error(\"OSC AtomicTimetag can not be encoded with empty value\");\n                    var t = this.value, e = t.seconds, n = t.fractions, r = new Uint8Array(8), o = new DataView(r.buffer);\n                    return o.setInt32(0, e, !1), o.setInt32(4, n, !1), r;\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    if (!(t instanceof DataView)) throw new Error(\"OSC AtomicTimetag expects an instance of type DataView\");\n                    var n = t.getUint32(e, !1), r = t.getUint32(e + 4, !1);\n                    return this.value = new U(n, r), this.offset = e + 8, this.offset;\n                }\n            }\n        ]);\n    }(x), F = function(e) {\n        function n(e) {\n            if (i(this, n), e && !S(e)) throw new Error(\"OSC AtomicBlob constructor expects value of type Uint8Array\");\n            return t(this, n, [\n                e\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    if (O(this.value)) throw new Error(\"OSC AtomicBlob can not be encoded with empty value\");\n                    var t = P(this.value.byteLength), e = new Uint8Array(t + 4);\n                    return new DataView(e.buffer).setInt32(0, this.value.byteLength, !1), e.set(this.value, 4), e;\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    if (!(t instanceof DataView)) throw new Error(\"OSC AtomicBlob expects an instance of type DataView\");\n                    var n = t.getInt32(e, !1);\n                    return this.value = new Uint8Array(t.buffer, e + 4, n), this.offset = P(e + 4 + n), this.offset;\n                }\n            }\n        ]);\n    }(x), R = function(e) {\n        function n(e) {\n            if (i(this, n), e && !v(e)) throw new Error(\"OSC AtomicFloat32 constructor expects value of type float\");\n            return t(this, n, [\n                e\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    return p(f(n.prototype), \"pack\", this).call(this, \"setFloat32\", 4);\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    return p(f(n.prototype), \"unpackWithMethod\", this).call(this, t, \"getFloat32\", 4, e);\n                }\n            }\n        ]);\n    }(x), z = function(e) {\n        function n(e) {\n            if (i(this, n), e && !v(e)) throw new Error(\"OSC AtomicFloat64 constructor expects value of type float\");\n            return t(this, n, [\n                e\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    return p(f(n.prototype), \"pack\", this).call(this, \"setFloat64\", 8);\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    return p(f(n.prototype), \"unpackWithMethod\", this).call(this, t, \"getFloat64\", 8, e);\n                }\n            }\n        ]);\n    }(x), G = BigInt(\"9223372036854775807\"), Z = BigInt(\"-9223372036854775808\"), q = function(e) {\n        function n(e) {\n            if (i(this, n), e && \"bigint\" != typeof e) throw new Error(\"OSC AtomicInt64 constructor expects value of type BigInt\");\n            if (e && (e < Z || e > G)) throw new Error(\"OSC AtomicInt64 value is out of bounds\");\n            var r;\n            return e && (r = BigInt.asIntN(64, e)), t(this, n, [\n                r\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    return p(f(n.prototype), \"pack\", this).call(this, \"setBigInt64\", 8);\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    return p(f(n.prototype), \"unpackWithMethod\", this).call(this, t, \"getBigInt64\", 8, e);\n                }\n            }\n        ]);\n    }(x), J = BigInt(\"18446744073709551615\"), K = function(e) {\n        function n(e) {\n            if (i(this, n), e && \"bigint\" != typeof e) throw new Error(\"OSC AtomicUInt64 constructor expects value of type BigInt\");\n            if (e && (e < 0 || e > J)) throw new Error(\"OSC AtomicUInt64 value is out of bounds\");\n            var r;\n            return e && (r = BigInt.asUintN(64, e)), t(this, n, [\n                r\n            ]);\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"pack\",\n                value: function() {\n                    return p(f(n.prototype), \"pack\", this).call(this, \"setBigUint64\", 8);\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    return p(f(n.prototype), \"unpackWithMethod\", this).call(this, t, \"getBigUint64\", 8, e);\n                }\n            }\n        ]);\n    }(x), Q = !0, X = !1, Y = null, $ = 1 / 0, tt = a(function t(e, n) {\n        var r = this;\n        if (i(this, t), this.offset = 0, this.address = \"\", this.types = \"\", this.args = [], !O(e)) {\n            if (!w(e) && !k(e)) throw new Error(\"OSC Message constructor first argument (address) must be a string or array\");\n            this.address = D(e);\n        }\n        if (!O(n)) {\n            if (!k(n)) throw new Error(\"OSC Message constructor second argument (args) must be an array\");\n            n.forEach(function(t) {\n                return r.add(t.type, t.value);\n            });\n        }\n    }, [\n        {\n            key: \"add\",\n            value: function(t, e) {\n                if (O(t)) throw new Error(\"OSC Message needs a valid OSC Atomic Data Type\");\n                \"N\" === t ? this.args.push(Y) : \"T\" === t ? this.args.push(Q) : \"F\" === t ? this.args.push(X) : \"I\" === t ? this.args.push($) : this.args.push(e), this.types += t;\n            }\n        },\n        {\n            key: \"pack\",\n            value: function() {\n                var t = this;\n                if (0 === this.address.length || \"/\" !== this.address[0]) throw new Error(\"OSC Message has an invalid address\");\n                var e = new M;\n                if (e.add(new N(this.address)), e.add(new N(\",\".concat(this.types))), this.args.length > 0) {\n                    var n;\n                    if (this.args.length > this.types.length) throw new Error(\"OSC Message argument and type tag mismatch\");\n                    this.args.forEach(function(r, o) {\n                        var i = t.types[o];\n                        if (\"i\" === i) n = new T(r);\n                        else if (\"h\" === i) n = new q(r);\n                        else if (\"t\" === i) n = new K(r);\n                        else if (\"f\" === i) n = new R(r);\n                        else if (\"d\" === i) n = new z(r);\n                        else if (\"s\" === i) n = new N(r);\n                        else if (\"b\" === i) n = new F(r);\n                        else if (\"T\" === i) n = Q;\n                        else if (\"F\" === i) n = X;\n                        else if (\"N\" === i) n = Y;\n                        else {\n                            if (\"I\" !== i) throw new Error(\"OSC Message found unknown argument type\");\n                            n = $;\n                        }\n                        e.add(n);\n                    });\n                }\n                return e.merge();\n            }\n        },\n        {\n            key: \"unpack\",\n            value: function(t) {\n                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                if (!(t instanceof DataView)) throw new Error(\"OSC Message expects an instance of type DataView.\");\n                var n = new N;\n                n.unpack(t, e);\n                var r = new N;\n                if (r.unpack(t, n.offset), 0 === n.value.length || \"/\" !== n.value[0]) throw new Error(\"OSC Message found malformed or missing address string\");\n                if (0 === r.value.length && \",\" !== r.value[0]) throw new Error(\"OSC Message found malformed or missing type string\");\n                for(var o, i, s = r.offset, a = [], u = 1; u < r.value.length; u += 1){\n                    if (o = null, \"i\" === (i = r.value[u])) o = new T;\n                    else if (\"h\" === i) o = new q;\n                    else if (\"t\" === i) o = new K;\n                    else if (\"f\" === i) o = new R;\n                    else if (\"d\" === i) o = new z;\n                    else if (\"s\" === i) o = new N;\n                    else if (\"b\" === i) o = new F;\n                    else if (\"T\" === i) a.push(Q);\n                    else if (\"F\" === i) a.push(X);\n                    else if (\"N\" === i) a.push(Y);\n                    else {\n                        if (\"I\" !== i) throw new Error(\"OSC Message found unsupported argument type\");\n                        a.push($);\n                    }\n                    o && (s = o.unpack(t, s), a.push(o.value));\n                }\n                return this.offset = s, this.address = n.value, this.types = r.value, this.args = a, this.offset;\n            }\n        }\n    ]), et = function(e) {\n        function n(e) {\n            var r, o;\n            i(this, n);\n            for(var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), u = 1; u < s; u++)a[u - 1] = arguments[u];\n            return a.length > 0 && a[0] instanceof Array && (o = a.shift()), r = t(this, n, [\n                e,\n                o\n            ]), a.length > 0 && (r.types = a.map(function(t) {\n                return j(t);\n            }).join(\"\"), r.args = a), r;\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"add\",\n                value: function(t) {\n                    p(f(n.prototype), \"add\", this).call(this, j(t), t);\n                }\n            }\n        ]);\n    }(tt), nt = \"#bundle\", rt = function() {\n        function t() {\n            var e = this;\n            i(this, t), this.offset = 0, this.timetag = new _, this.bundleElements = [];\n            for(var n = arguments.length, r = new Array(n), o = 0; o < n; o++)r[o] = arguments[o];\n            r.length > 0 && (r[0] instanceof Date || d(r[0]) ? this.timetag = new _(r[0]) : k(r[0]) ? (r[0].forEach(function(t) {\n                e.add(t);\n            }), r.length > 1 && (r[1] instanceof Date || d(r[1])) && (this.timetag = new _(r[1]))) : r.forEach(function(t) {\n                e.add(t);\n            }));\n        }\n        return a(t, [\n            {\n                key: \"timestamp\",\n                value: function(t) {\n                    if (!d(t)) throw new Error(\"OSC Bundle needs an integer for setting the timestamp\");\n                    this.timetag = new _(t);\n                }\n            },\n            {\n                key: \"add\",\n                value: function(e) {\n                    if (!(e instanceof et || e instanceof t)) throw new Error(\"OSC Bundle contains only Messages and Bundles\");\n                    this.bundleElements.push(e);\n                }\n            },\n            {\n                key: \"pack\",\n                value: function() {\n                    var t = new M;\n                    return t.add(new N(nt)), this.timetag || (this.timetag = new _), t.add(this.timetag), this.bundleElements.forEach(function(e) {\n                        t.add(new T(e.pack().byteLength)), t.add(e);\n                    }), t.merge();\n                }\n            },\n            {\n                key: \"unpack\",\n                value: function(e) {\n                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                    if (!(e instanceof DataView)) throw new Error(\"OSC Bundle expects an instance of type DataView\");\n                    var r = new N;\n                    if (r.unpack(e, n), r.value !== nt) throw new Error(\"OSC Bundle does not contain a valid #bundle head\");\n                    var o = new _, i = o.unpack(e, r.offset);\n                    for(this.bundleElements = []; i < e.byteLength;){\n                        var s = new N, a = new T;\n                        i = a.unpack(e, i);\n                        var u = void 0;\n                        s.unpack(e, i), i = (u = s.value === nt ? new t : new et).unpack(e, i), this.bundleElements.push(u);\n                    }\n                    return this.offset = i, this.timetag = o, this.offset;\n                }\n            }\n        ]);\n    }(), ot = a(function t(e) {\n        if (i(this, t), e && !(e instanceof et || e instanceof rt)) throw new Error(\"OSC Packet value has to be Message or Bundle\");\n        this.value = e, this.offset = 0;\n    }, [\n        {\n            key: \"pack\",\n            value: function() {\n                if (!this.value) throw new Error(\"OSC Packet can not be encoded with empty body\");\n                return this.value.pack();\n            }\n        },\n        {\n            key: \"unpack\",\n            value: function(t) {\n                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n                if (!(t instanceof DataView)) throw new Error(\"OSC Packet expects an instance of type DataView\");\n                if (t.byteLength % 4 != 0) throw new Error(\"OSC Packet byteLength has to be a multiple of four\");\n                var n, r = new N;\n                return r.unpack(t, e), (n = r.value === nt ? new rt : new et).unpack(t, e), this.offset = n.offset, this.value = n, this.offset;\n            }\n        }\n    ]), it = {\n        discardLateMessages: !1\n    }, st = a(function t(e) {\n        i(this, t), this.options = r(r({}, it), e), this.addressHandlers = [], this.eventHandlers = {\n            open: [],\n            error: [],\n            close: []\n        }, this.uuid = 0;\n    }, [\n        {\n            key: \"dispatch\",\n            value: function(t, e) {\n                var n = this;\n                if (!(t instanceof ot)) throw new Error(\"OSC EventHander dispatch() accepts only arguments of type Packet\");\n                if (!t.value) throw new Error(\"OSC EventHander dispatch() can't read empty Packets\");\n                if (t.value instanceof rt) {\n                    var r = t.value;\n                    return r.bundleElements.forEach(function(t) {\n                        if (t instanceof rt) {\n                            if (r.timetag.value.timestamp() < t.timetag.value.timestamp()) throw new Error(\"OSC Bundle timestamp is older than the timestamp of enclosed Bundles\");\n                            return n.dispatch(new ot(t));\n                        }\n                        if (t instanceof et) {\n                            var o = t;\n                            return n.notify(o.address, o, r.timetag.value.timestamp(), e);\n                        }\n                        throw new Error(\"OSC EventHander dispatch() can't dispatch unknown Packet value\");\n                    });\n                }\n                if (t.value instanceof et) {\n                    var o = t.value;\n                    return this.notify(o.address, o, 0, e);\n                }\n                throw new Error(\"OSC EventHander dispatch() can't dispatch unknown Packet value\");\n            }\n        },\n        {\n            key: \"call\",\n            value: function(t, e, n) {\n                var r = !1;\n                if (w(t) && t in this.eventHandlers) return this.eventHandlers[t].forEach(function(t) {\n                    t.callback(e, n), r = !0;\n                }), r;\n                var o = Object.keys(this.addressHandlers), i = this.addressHandlers;\n                return o.forEach(function(o) {\n                    var s = !1, a = new RegExp(B(D(t)), \"g\");\n                    if (a.test(o) && o.length === a.lastIndex && (s = !0), !s) {\n                        var u = new RegExp(B(D(o)), \"g\");\n                        u.test(t) && t.length === u.lastIndex && (s = !0);\n                    }\n                    s && i[o].forEach(function(t) {\n                        t.callback(e, n), r = !0;\n                    });\n                }), r;\n            }\n        },\n        {\n            key: \"notify\",\n            value: function() {\n                for(var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n];\n                if (0 === e.length) throw new Error(\"OSC EventHandler can not be called without any argument\");\n                try {\n                    if (e[0] instanceof ot) return this.dispatch(e[0], e[1]);\n                    if (e[0] instanceof rt || e[0] instanceof et) return this.dispatch(new ot(e[0]), e[1]);\n                    if (!w(e[0])) {\n                        var r = new ot;\n                        return r.unpack(I(e[0])), this.dispatch(r, e[1]);\n                    }\n                    var o = e[0], i = null;\n                    e.length > 1 && (i = e[1]);\n                    var s = null;\n                    if (e.length > 2) {\n                        if (d(e[2])) s = e[2];\n                        else {\n                            if (!(e[2] instanceof Date)) throw new Error(\"OSC EventHandler timestamp has to be a number or Date\");\n                            s = e[2].getTime();\n                        }\n                    }\n                    var a = null;\n                    if (e.length >= 3 && (a = e[3]), s) {\n                        var u = Date.now();\n                        if (u > s && !this.options.discardLateMessages) return this.call(o, i, a);\n                        var c = this;\n                        return setTimeout(function() {\n                            c.call(o, i, a);\n                        }, s - u), !0;\n                    }\n                    return this.call(o, i, a);\n                } catch (t) {\n                    return this.notify(\"error\", t), !1;\n                }\n            }\n        },\n        {\n            key: \"on\",\n            value: function(t, e) {\n                if (!w(t) && !k(t)) throw new Error(\"OSC EventHandler accepts only strings or arrays for address patterns\");\n                if (!m(e)) throw new Error(\"OSC EventHandler callback has to be a function\");\n                this.uuid += 1;\n                var n = {\n                    id: this.uuid,\n                    callback: e\n                };\n                if (w(t) && t in this.eventHandlers) return this.eventHandlers[t].push(n), this.uuid;\n                var r = D(t);\n                return r in this.addressHandlers || (this.addressHandlers[r] = []), this.addressHandlers[r].push(n), this.uuid;\n            }\n        },\n        {\n            key: \"off\",\n            value: function(t, e) {\n                if (!w(t) && !k(t)) throw new Error(\"OSC EventHandler accepts only strings or arrays for address patterns\");\n                if (!d(e)) throw new Error(\"OSC EventHandler subscription id has to be a number\");\n                var n, r;\n                return w(t) && t in this.eventHandlers ? (n = t, r = this.eventHandlers) : (n = D(t), r = this.addressHandlers), n in r && r[n].some(function(t, o) {\n                    return t.id === e && (r[n].splice(o, 1), !0);\n                });\n            }\n        }\n    ]), at = a(function t() {\n        if (i(this, t), this.constructor === t) throw new Error(\"Plugin is an abstract class. Please create or use an implementation!\");\n    }, [\n        {\n            key: \"status\",\n            value: function() {\n                throw new Error(\"Abstract method!\");\n            }\n        },\n        {\n            key: \"open\",\n            value: function() {\n                throw new Error(\"Abstract method!\");\n            }\n        },\n        {\n            key: \"close\",\n            value: function() {\n                throw new Error(\"Abstract method!\");\n            }\n        },\n        {\n            key: \"send\",\n            value: function(t) {\n                throw new Error(\"Abstract method!\");\n            }\n        }\n    ]), ut = 0, ct = 1, ft = 2, lt = 3, ht = function(e) {\n        function n() {\n            throw i(this, n), t(this, n), new Error(\"DatagramPlugin can not be used in browser context\");\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"registerNotify\",\n                value: function(t) {\n                    this.notify = t;\n                }\n            },\n            {\n                key: \"status\",\n                value: function() {\n                    return this.socketStatus;\n                }\n            },\n            {\n                key: \"open\",\n                value: function() {\n                    var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = r(r({}, this.options.open), e), o = n.port, i = n.exclusive;\n                    this.socketStatus = ut, this.socket.bind({\n                        address: n.host,\n                        port: o,\n                        exclusive: i\n                    }, function() {\n                        t.socketStatus = ct, t.notify(\"open\");\n                    });\n                }\n            },\n            {\n                key: \"close\",\n                value: function() {\n                    var t = this;\n                    this.socketStatus = ft, this.socket.close(function() {\n                        t.socketStatus = lt, t.notify(\"close\");\n                    });\n                }\n            },\n            {\n                key: \"send\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = r(r({}, this.options.send), e), o = n.port, i = n.host;\n                    this.socket.send($dddc8561b083d642$require$Buffer.from(t), 0, t.byteLength, o, i);\n                }\n            }\n        ]);\n    }(at);\n    var pt = \"undefined\" != typeof WebSocket ? WebSocket : \"undefined\" != typeof MozWebSocket ? MozWebSocket : \"undefined\" != typeof $parcel$global ? $parcel$global.WebSocket || $parcel$global.MozWebSocket : \"undefined\" != typeof window ? window.WebSocket || window.MozWebSocket : \"undefined\" != typeof self ? self.WebSocket || self.MozWebSocket : void 0, dt = void 0, vt = 0, wt = 1, yt = 2, gt = 3, kt = {\n        udpServer: {\n            host: \"localhost\",\n            port: 41234,\n            exclusive: !1\n        },\n        udpClient: {\n            host: \"localhost\",\n            port: 41235\n        },\n        wsServer: {\n            host: \"localhost\",\n            port: 8080\n        },\n        receiver: \"ws\"\n    };\n    function bt(t, e) {\n        return r(r(r(r({}, kt), t), e), {}, {\n            udpServer: r(r(r({}, kt.udpServer), t.udpServer), e.udpServer),\n            udpClient: r(r(r({}, kt.udpClient), t.udpClient), e.udpClient),\n            wsServer: r(r(r({}, kt.wsServer), t.wsServer), e.wsServer)\n        });\n    }\n    var mt = function(e) {\n        function n() {\n            throw i(this, n), t(this, n), new Error(\"BridgePlugin can not be used in browser context\");\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"registerNotify\",\n                value: function(t) {\n                    this.notify = t;\n                }\n            },\n            {\n                key: \"status\",\n                value: function() {\n                    return this.socketStatus;\n                }\n            },\n            {\n                key: \"open\",\n                value: function() {\n                    var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = bt(this.options, e);\n                    this.socketStatus = vt, this.socket.bind({\n                        address: n.udpServer.host,\n                        port: n.udpServer.port,\n                        exclusive: n.udpServer.exclusive\n                    }, function() {\n                        var e = {};\n                        n.wsServer.server ? e.server = n.wsServer.server : e = n.wsServer, t.websocket = new dt(e), t.websocket.binaryType = \"arraybuffer\", t.websocket.on(\"listening\", function() {\n                            t.socketStatus = wt, t.notify(\"open\");\n                        }), t.websocket.on(\"error\", function(e) {\n                            t.notify(\"error\", e);\n                        }), t.websocket.on(\"connection\", function(e) {\n                            e.on(\"message\", function(e, n) {\n                                t.send(e, {\n                                    receiver: \"udp\"\n                                }), t.notify(new Uint8Array(e), n);\n                            });\n                        });\n                    });\n                }\n            },\n            {\n                key: \"close\",\n                value: function() {\n                    var t = this;\n                    this.socketStatus = yt, this.socket.close(function() {\n                        t.websocket.close(function() {\n                            t.socketStatus = gt, t.notify(\"close\");\n                        });\n                    });\n                }\n            },\n            {\n                key: \"send\",\n                value: function(t) {\n                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = bt(this.options, e), r = n.receiver;\n                    if (\"udp\" === r) {\n                        var o = t instanceof $dddc8561b083d642$require$Buffer ? t : $dddc8561b083d642$require$Buffer.from(t);\n                        this.socket.send(o, 0, o.byteLength, n.udpClient.port, n.udpClient.host);\n                    } else {\n                        if (\"ws\" !== r) throw new Error(\"BridgePlugin can not send message to unknown receiver\");\n                        this.websocket.clients.forEach(function(e) {\n                            e.send(t, {\n                                binary: !0\n                            });\n                        });\n                    }\n                }\n            }\n        ]);\n    }(at), St = -1, Et = 0, Ot = 1, Ct = 2, Pt = 3, At = {\n        host: \"localhost\",\n        port: 8080,\n        secure: !1,\n        protocol: []\n    }, It = function(e) {\n        function n(e) {\n            var o;\n            if (i(this, n), o = t(this, n), !pt) throw new Error(\"WebsocketClientPlugin can't find a WebSocket class\");\n            return o.options = r(r({}, At), e), o.socket = null, o.socketStatus = St, o.notify = function() {}, o;\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"registerNotify\",\n                value: function(t) {\n                    this.notify = t;\n                }\n            },\n            {\n                key: \"status\",\n                value: function() {\n                    return this.socketStatus;\n                }\n            },\n            {\n                key: \"open\",\n                value: function() {\n                    var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = r(r({}, this.options), e), o = n.port, i = n.host, s = n.secure, a = n.protocol;\n                    this.socket && this.close();\n                    var u = s ? \"wss\" : \"ws\", c = {\n                        address: i,\n                        family: u,\n                        port: o,\n                        size: 0\n                    };\n                    this.socket = new pt(\"\".concat(u, \"://\").concat(i, \":\").concat(o), a), this.socket.binaryType = \"arraybuffer\", this.socketStatus = Et, this.socket.onopen = function() {\n                        t.socketStatus = Ot, t.notify(\"open\");\n                    }, this.socket.onclose = function() {\n                        t.socketStatus = Pt, t.notify(\"close\");\n                    }, this.socket.onerror = function(e) {\n                        t.notify(\"error\", e);\n                    }, this.socket.onmessage = function(e) {\n                        t.notify(e.data, c);\n                    };\n                }\n            },\n            {\n                key: \"close\",\n                value: function() {\n                    this.socketStatus = Ct, this.socket.close();\n                }\n            },\n            {\n                key: \"send\",\n                value: function(t) {\n                    this.socket.send(t);\n                }\n            }\n        ]);\n    }(at), jt = 0, Dt = 1, Bt = 2, Mt = 3, xt = function(e) {\n        function n(e) {\n            throw i(this, n), t(this, n), new Error(\"WebsocketServerPlugin can not be used in browser context\");\n        }\n        return c(n, e), a(n, [\n            {\n                key: \"registerNotify\",\n                value: function(t) {\n                    this.notify = t;\n                }\n            },\n            {\n                key: \"status\",\n                value: function() {\n                    return this.socketStatus;\n                }\n            },\n            {\n                key: \"open\",\n                value: function() {\n                    var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = r(r({}, this.options), e), o = n.port, i = n.host, s = {\n                        address: i,\n                        family: \"wsserver\",\n                        port: o,\n                        size: 0\n                    };\n                    this.socket && this.close(), n.server ? this.socket = new dt({\n                        server: n.server\n                    }) : this.socket = new dt({\n                        host: i,\n                        port: o\n                    }), this.socket.binaryType = \"arraybuffer\", this.socketStatus = jt, this.socket.on(\"listening\", function() {\n                        t.socketStatus = Dt, t.notify(\"open\");\n                    }), this.socket.on(\"error\", function(e) {\n                        t.notify(\"error\", e);\n                    }), this.socket.on(\"connection\", function(e) {\n                        e.on(\"message\", function(e) {\n                            t.notify(new Uint8Array(e), s);\n                        });\n                    });\n                }\n            },\n            {\n                key: \"close\",\n                value: function() {\n                    var t = this;\n                    this.socketStatus = Bt, this.socket.close(function() {\n                        t.socketStatus = Mt, t.notify(\"close\");\n                    });\n                }\n            },\n            {\n                key: \"send\",\n                value: function(t) {\n                    this.socket.clients.forEach(function(e) {\n                        e.send(t, {\n                            binary: !0\n                        });\n                    });\n                }\n            }\n        ]);\n    }(at), Tt = {\n        discardLateMessages: !1\n    }, Ht = a(function t(e) {\n        if (i(this, t), e && !b(e)) throw new Error(\"OSC options argument has to be an object.\");\n        this.options = r(r({}, Tt), e), this.options.plugin || (this.options.plugin = new It), this.eventHandler = new st({\n            discardLateMessages: this.options.discardLateMessages\n        });\n        var n = this.eventHandler;\n        this.options.plugin && this.options.plugin.registerNotify && this.options.plugin.registerNotify(function() {\n            return n.notify.apply(n, arguments);\n        });\n    }, [\n        {\n            key: \"on\",\n            value: function(t, e) {\n                if (!w(t) || !m(e)) throw new Error(\"OSC on() needs event- or address string and callback function\");\n                return this.eventHandler.on(t, e);\n            }\n        },\n        {\n            key: \"off\",\n            value: function(t, e) {\n                if (!w(t) || !d(e)) throw new Error(\"OSC off() needs string and number (subscriptionId) to unsubscribe\");\n                return this.eventHandler.off(t, e);\n            }\n        },\n        {\n            key: \"open\",\n            value: function(t) {\n                if (t && !b(t)) throw new Error(\"OSC open() options argument needs to be an object\");\n                if (!this.options.plugin || !m(this.options.plugin.open)) throw new Error(\"OSC Plugin API #open is not implemented!\");\n                return this.options.plugin.open(t);\n            }\n        },\n        {\n            key: \"status\",\n            value: function() {\n                if (!this.options.plugin || !m(this.options.plugin.status)) throw new Error(\"OSC Plugin API #status is not implemented!\");\n                return this.options.plugin.status();\n            }\n        },\n        {\n            key: \"close\",\n            value: function() {\n                if (!this.options.plugin || !m(this.options.plugin.close)) throw new Error(\"OSC Plugin API #close is not implemented!\");\n                return this.options.plugin.close();\n            }\n        },\n        {\n            key: \"send\",\n            value: function(t, e) {\n                if (!this.options.plugin || !m(this.options.plugin.send)) throw new Error(\"OSC Plugin API #send is not implemented!\");\n                if (!(t instanceof tt || t instanceof et || t instanceof rt || t instanceof ot)) throw new Error(\"OSC send() needs Messages, Bundles or Packets\");\n                if (e && !b(e)) throw new Error(\"OSC send() options argument has to be an object\");\n                return this.options.plugin.send(t.pack(), e);\n            }\n        }\n    ]);\n    return Ht.STATUS = {\n        IS_NOT_INITIALIZED: -1,\n        IS_CONNECTING: 0,\n        IS_OPEN: 1,\n        IS_CLOSING: 2,\n        IS_CLOSED: 3\n    }, Ht.Packet = ot, Ht.Bundle = rt, Ht.Message = et, Ht.TypedMessage = tt, Ht.Plugin = at, Ht.DatagramPlugin = ht, Ht.WebsocketClientPlugin = It, Ht.WebsocketServerPlugin = xt, Ht.BridgePlugin = mt, Ht;\n});\n\n\n//const plugin = new OSC.WebsocketClientPlugin({ host: '192.168.8.123', port: 8080 })\nvar $e73bf42412feb220$var$plugin = {};\nvar $e73bf42412feb220$var$osc = {};\n//const osc = new OSC({ plugin: plugin })\n//osc.open(); // connect by default to ws://localhost:8080\n/**\n * Creates a div with a specified number of knobs.\n * @param {number} numKnobs - The number of knobs to create.\n */ function $e73bf42412feb220$var$createKnobs(numKnobs) {\n    // Remove existing knobs div if it exists\n    $e73bf42412feb220$var$removeKnobs();\n    // Create the container div\n    const knobsDiv = document.createElement('div');\n    knobsDiv.className = 'knobs';\n    // Generate the knobs\n    for(let i = 1; i <= numKnobs; i++){\n        const knob = document.createElement('webaudio-knob');\n        knob.id = `knob${i}`;\n        knob.setAttribute('min', '0');\n        knob.setAttribute('max', '1');\n        knob.setAttribute('step', '0.001');\n        knob.setAttribute('colors', '#81a1c1;#4c566a;#444');\n        knob.setAttribute('width', '46');\n        knob.setAttribute('height', '46');\n        knobsDiv.appendChild(knob);\n    }\n    // Add the knobs div to the app container\n    const app = document.querySelector('.app');\n    if (app) app.appendChild(knobsDiv);\n    else console.error('No element with class \"app\" found.');\n}\n/**\n * Removes the knobs div from the DOM.\n */ function $e73bf42412feb220$var$removeKnobs() {\n    const knobsDiv = document.querySelector('.knobs');\n    if (knobsDiv) knobsDiv.remove();\n}\n//osc.open({ port: 9000 })\n$e73bf42412feb220$var$createKnobs(128);\n// Add event listeners to all knobs\nfor(let i = 1; i <= 128; i++){\n    const knob = document.getElementById(`knob${i}`);\n    if (knob) knob.addEventListener(\"input\", (event)=>{\n        const value = parseFloat(event.target.value);\n        const path = `/virtualctl/K${String(i.toString(16)).padStart(2, \"0\")}`; // e.g., /virtualctl/k01\n        console.log(`Sending OSC: ${path} ${value}`);\n        // Send the OSC message\n        const message = new $dddc8561b083d642$exports.Message(path, parseFloat(value));\n        $e73bf42412feb220$var$osc.send(message);\n    });\n}\nvar $5cccb5591bb3b1ca$exports = {};\n$5cccb5591bb3b1ca$exports = new URL(\"sw.js\", import.meta.url).toString();\n\n\n//// Register the service worker for PWA\nasync function $e73bf42412feb220$var$registerSW() {\n    console.log(\"Registering\");\n    console.log(navigator);\n    if ('serviceWorker' in navigator) try {\n        await navigator.serviceWorker.register($5cccb5591bb3b1ca$exports);\n    } catch (e) {\n        console.log(\"Service Worker registration failed:\", e);\n    }\n}\nfunction $e73bf42412feb220$var$connect(ip) {\n    $e73bf42412feb220$var$plugin = new $dddc8561b083d642$exports.WebsocketClientPlugin({\n        host: ip,\n        port: 8080\n    });\n    $e73bf42412feb220$var$osc = new $dddc8561b083d642$exports({\n        plugin: $e73bf42412feb220$var$plugin\n    });\n    $e73bf42412feb220$var$osc.open(); // connect by default to ws://localhost:8080\n}\nwindow.addEventListener('load', ()=>{\n    const ip = document.getElementById('hostaddr').value;\n    console.log(\"C'est parti!!\");\n    console.log(ip);\n    $e73bf42412feb220$var$connect(ip);\n    $e73bf42412feb220$var$registerSW();\n});\nconst $e73bf42412feb220$var$ipElement = document.getElementById('hostaddr');\n$e73bf42412feb220$var$ipElement.addEventListener(\"change\", (event)=>{\n    console.log(\"Changed IP, reconnecting\");\n    console.log(event.target.value);\n    $e73bf42412feb220$var$connect(event.target.value);\n});\nwindow.onbeforeunload = function() {\n    console.log(\"Your work will be lost.\");\n};\nwindow.addEventListener('popstate', ()=>{\n    console.log('User clicked back button');\n});\n\n\n//# sourceMappingURL=index.e121266c.js.map\n","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(new __parcel__URL__(\"\").toString(),JSON.parse(\"[\\\"izUj7\\\",\\\"index.e121266c.js\\\",\\\"7yeQP\\\",\\\"sw.js\\\"]\"));","const OSC = require('osc-js')\n//const plugin = new OSC.WebsocketClientPlugin({ host: '192.168.8.123', port: 8080 })\nvar plugin = {};\nvar osc ={};\n//const osc = new OSC({ plugin: plugin })\n\n//osc.open(); // connect by default to ws://localhost:8080\n\n/**\n * Creates a div with a specified number of knobs.\n * @param {number} numKnobs - The number of knobs to create.\n */\nfunction createKnobs(numKnobs) {\n    // Remove existing knobs div if it exists\n    removeKnobs();\n\n    // Create the container div\n    const knobsDiv = document.createElement('div');\n    knobsDiv.className = 'knobs';\n\n    // Generate the knobs\n    for (let i = 1; i <= numKnobs; i++) {\n        const knob = document.createElement('webaudio-knob');\n        knob.id = `knob${i}`;\n        knob.setAttribute('min', '0');\n        knob.setAttribute('max', '1');\n        knob.setAttribute('step', '0.001');\n        knob.setAttribute('colors', '#81a1c1;#4c566a;#444');\n        knob.setAttribute('width', '46');\n        knob.setAttribute('height', '46');\n\n        knobsDiv.appendChild(knob);\n    }\n\n    // Add the knobs div to the app container\n    const app = document.querySelector('.app');\n    if (app) {\n        app.appendChild(knobsDiv);\n    } else {\n        console.error('No element with class \"app\" found.');\n    }\n}\n\n/**\n * Removes the knobs div from the DOM.\n */\nfunction removeKnobs() {\n    const knobsDiv = document.querySelector('.knobs');\n    if (knobsDiv) {\n        knobsDiv.remove();\n    }\n}\n\n//osc.open({ port: 9000 })\n\ncreateKnobs(128);\n// Add event listeners to all knobs\nfor (let i = 1; i <= 128; i++) {\n  const knob = document.getElementById(`knob${i}`);\n  if (knob) {\n    knob.addEventListener(\"input\", (event) => {\n      const value = parseFloat(event.target.value);\n      const path = `/virtualctl/K${String(i.toString(16)).padStart(2, \"0\")}`; // e.g., /virtualctl/k01\n      console.log(`Sending OSC: ${path} ${value}`);\n\n      // Send the OSC message\n      const message = new OSC.Message(path, parseFloat(value));\n      osc.send(message)\n    });\n  }\n}\n\n//// Register the service worker for PWA\nasync function registerSW() {\n  console.log(\"Registering\");\n  console.log(navigator);\n  if ('serviceWorker' in navigator) {\n    try {\n      await navigator.serviceWorker.register(new URL('./sw.js', import.meta.url));\n    } catch(e) {\n      console.log(\"Service Worker registration failed:\", e);\n    }\n  }\n}\n\nfunction connect(ip) {\n  plugin = new OSC.WebsocketClientPlugin({ host: ip, port: 8080 })\n  osc = new OSC({ plugin: plugin })\n  osc.open(); // connect by default to ws://localhost:8080\n}\n\nwindow.addEventListener('load',() => {\n  const ip = document.getElementById('hostaddr').value;\n  console.log(\"C'est parti!!\");\n  console.log(ip);\n  connect(ip);\n  registerSW();\n});\n\nconst ipElement = document.getElementById('hostaddr');\n\nipElement.addEventListener(\"change\", (event) => {\n  console.log(\"Changed IP, reconnecting\");\n  console.log(event.target.value);\n  connect(event.target.value);\n});\n\n\n\n\nwindow.onbeforeunload = function() { console.log(\"Your work will be lost.\"); };\n\nwindow.addEventListener('popstate', () => {\n  console.log('User clicked back button');\n});\n","!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).OSC=e()}(this,(function(){\"use strict\";function t(t,n,r){return n=f(n),function(t,e){if(e&&(\"object\"==typeof e||\"function\"==typeof e))return e;if(void 0!==e)throw new TypeError(\"Derived constructors may only return object or undefined\");return function(t){if(void 0===t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return t}(t)}(t,e()?Reflect.construct(n,r||[],f(t).constructor):n.apply(t,r))}function e(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(e=function(){return!!t})()}function n(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function r(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?n(Object(r),!0).forEach((function(e){u(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function o(t){var e=function(t,e){if(\"object\"!=typeof t||!t)return t;var n=t[Symbol.toPrimitive];if(void 0!==n){var r=n.call(t,e||\"default\");if(\"object\"!=typeof r)return r;throw new TypeError(\"@@toPrimitive must return a primitive value.\")}return(\"string\"===e?String:Number)(t)}(t,\"string\");return\"symbol\"==typeof e?e:e+\"\"}function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function s(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(t,o(r.key),r)}}function a(t,e,n){return e&&s(t.prototype,e),n&&s(t,n),Object.defineProperty(t,\"prototype\",{writable:!1}),t}function u(t,e,n){return(e=o(e))in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function c(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function\");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,\"prototype\",{writable:!1}),e&&l(t,e)}function f(t){return f=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},f(t)}function l(t,e){return l=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},l(t,e)}function h(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=f(t)););return t}function p(){return p=\"undefined\"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(t,e,n){var r=h(t,e);if(r){var o=Object.getOwnPropertyDescriptor(r,e);return o.get?o.get.call(arguments.length<3?t:n):o.value}},p.apply(this,arguments)}function d(t){return Number(t)===t&&t%1==0}function v(t){return Number(t)===t}function w(t){return\"string\"==typeof t}function y(t){return\"boolean\"==typeof t}function g(t){return t===1/0}function k(t){return\"[object Array]\"===Object.prototype.toString.call(t)}function b(t){return\"[object Object]\"===Object.prototype.toString.call(t)}function m(t){return\"function\"==typeof t}function S(t){return t instanceof Uint8Array}function E(t){return t instanceof Date}function O(t){return void 0===t}function C(t){return null===t}function P(t){return t+3&-4}function A(t){return Object.prototype.hasOwnProperty.call(\"undefined\"!=typeof global?global:window,t)}function I(t){return t.buffer?new DataView(t.buffer):t instanceof ArrayBuffer?new DataView(t):new DataView(new Uint8Array(t))}function j(t){if(d(t))return\"i\";if(e=t,Number(e)===e&&e%1!=0)return\"f\";if(w(t))return\"s\";if(S(t))return\"b\";if(y(t))return t?\"T\":\"F\";if(C(t))return\"N\";if(g(t))return\"I\";var e;throw new Error(\"OSC typeTag() found unknown value type\")}function D(t){var e=\"\";if(k(t))return\"/\".concat(t.join(\"/\"));if(w(t))return(e=t).length>1&&\"/\"===e[e.length-1]&&(e=e.slice(0,e.length-1)),e.length>1&&\"/\"!==e[0]&&(e=\"/\".concat(e)),e;throw new Error(\"OSC prepareAddress() needs addresses of type array or string\")}function B(t){if(!w(t))throw new Error(\"OSC prepareRegExPattern() needs strings\");return t.replace(/\\./g,\"\\\\.\").replace(/\\(/g,\"\\\\(\").replace(/\\)/g,\"\\\\)\").replace(/\\{/g,\"(\").replace(/\\}/g,\")\").replace(/,/g,\"|\").replace(/\\[!/g,\"[^\").replace(/\\?/g,\".\").replace(/\\*/g,\".*\")}var M=a((function t(){i(this,t),this.data=[],this.byteLength=0}),[{key:\"add\",value:function(t){if(y(t)||g(t)||C(t))return this;var e=t.pack();return this.byteLength+=e.byteLength,this.data.push(e),this}},{key:\"merge\",value:function(){var t=new Uint8Array(this.byteLength),e=0;return this.data.forEach((function(n){t.set(n,e),e+=n.byteLength})),t}}]),x=a((function t(e){i(this,t),this.value=e,this.offset=0}),[{key:\"pack\",value:function(t,e){if(!t||!e)throw new Error(\"OSC Atomic cant't be packed without given method or byteLength\");var n=new Uint8Array(e),r=new DataView(n.buffer);if(O(this.value))throw new Error(\"OSC Atomic cant't be encoded with empty value\");return r[t](this.offset,this.value,!1),n}},{key:\"unpackWithMethod\",value:function(t,e,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(!(t&&e&&n))throw new Error(\"OSC Atomic cant't be unpacked without given dataView, method or byteLength\");if(!(t instanceof DataView))throw new Error(\"OSC Atomic expects an instance of type DataView\");return this.value=t[e](r,!1),this.offset=r+n,this.offset}}]),T=function(e){function n(e){if(i(this,n),e&&!d(e))throw new Error(\"OSC AtomicInt32 constructor expects value of type number\");return t(this,n,[e])}return c(n,e),a(n,[{key:\"pack\",value:function(){return p(f(n.prototype),\"pack\",this).call(this,\"setInt32\",4)}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p(f(n.prototype),\"unpackWithMethod\",this).call(this,t,\"getInt32\",4,e)}}])}(x),H=\"utf-8\";function L(t){if(A(\"Buffer\"))return Buffer.from(t).toString(H);if(A(\"TextDecoder\"))return new TextDecoder(H).decode(new Int8Array(t));for(var e=\"\",n=0;n<t.length;n+=65537)e+=String.fromCharCode.apply(null,t.slice(n,n+65537));return e}var N=function(e){function n(e){if(i(this,n),e&&!w(e))throw new Error(\"OSC AtomicString constructor expects value of type string\");return t(this,n,[e])}return c(n,e),a(n,[{key:\"pack\",value:function(){if(O(this.value))throw new Error(\"OSC AtomicString can not be encoded with empty value\");for(var t=\"\".concat(this.value,\"\\0\"),e=P(t.length),n=new Uint8Array(e),r=0;r<t.length;r+=1)n[r]=t.charCodeAt(r);return n}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(t instanceof DataView))throw new Error(\"OSC AtomicString expects an instance of type DataView\");for(var n,r=e,o=[];r<t.byteLength;r+=1){if(0===(n=t.getUint8(r))){r+=1;break}o.push(n)}if(r===t.length)throw new Error(\"OSC AtomicString found a malformed OSC string\");return this.offset=P(r),this.value=L(o),this.offset}}])}(x),V=2208988800,W=4294967296,U=a((function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(i(this,t),!d(e)||!d(n))throw new Error(\"OSC Timetag constructor expects values of type integer number\");this.seconds=e,this.fractions=n}),[{key:\"timestamp\",value:function(t){var e;if(\"number\"==typeof t){e=t/1e3;var n=Math.floor(e);return this.seconds=n+V,this.fractions=Math.round(W*(e-n)),t}return 1e3*((e=this.seconds-V)+Math.round(this.fractions/W))}}]),_=function(e){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now();i(this,n);var r=new U;return e instanceof U?r=e:d(e)?r.timestamp(e):E(e)&&r.timestamp(e.getTime()),t(this,n,[r])}return c(n,e),a(n,[{key:\"pack\",value:function(){if(O(this.value))throw new Error(\"OSC AtomicTimetag can not be encoded with empty value\");var t=this.value,e=t.seconds,n=t.fractions,r=new Uint8Array(8),o=new DataView(r.buffer);return o.setInt32(0,e,!1),o.setInt32(4,n,!1),r}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(t instanceof DataView))throw new Error(\"OSC AtomicTimetag expects an instance of type DataView\");var n=t.getUint32(e,!1),r=t.getUint32(e+4,!1);return this.value=new U(n,r),this.offset=e+8,this.offset}}])}(x),F=function(e){function n(e){if(i(this,n),e&&!S(e))throw new Error(\"OSC AtomicBlob constructor expects value of type Uint8Array\");return t(this,n,[e])}return c(n,e),a(n,[{key:\"pack\",value:function(){if(O(this.value))throw new Error(\"OSC AtomicBlob can not be encoded with empty value\");var t=P(this.value.byteLength),e=new Uint8Array(t+4);return new DataView(e.buffer).setInt32(0,this.value.byteLength,!1),e.set(this.value,4),e}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(t instanceof DataView))throw new Error(\"OSC AtomicBlob expects an instance of type DataView\");var n=t.getInt32(e,!1);return this.value=new Uint8Array(t.buffer,e+4,n),this.offset=P(e+4+n),this.offset}}])}(x),R=function(e){function n(e){if(i(this,n),e&&!v(e))throw new Error(\"OSC AtomicFloat32 constructor expects value of type float\");return t(this,n,[e])}return c(n,e),a(n,[{key:\"pack\",value:function(){return p(f(n.prototype),\"pack\",this).call(this,\"setFloat32\",4)}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p(f(n.prototype),\"unpackWithMethod\",this).call(this,t,\"getFloat32\",4,e)}}])}(x),z=function(e){function n(e){if(i(this,n),e&&!v(e))throw new Error(\"OSC AtomicFloat64 constructor expects value of type float\");return t(this,n,[e])}return c(n,e),a(n,[{key:\"pack\",value:function(){return p(f(n.prototype),\"pack\",this).call(this,\"setFloat64\",8)}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p(f(n.prototype),\"unpackWithMethod\",this).call(this,t,\"getFloat64\",8,e)}}])}(x),G=BigInt(\"9223372036854775807\"),Z=BigInt(\"-9223372036854775808\"),q=function(e){function n(e){if(i(this,n),e&&\"bigint\"!=typeof e)throw new Error(\"OSC AtomicInt64 constructor expects value of type BigInt\");if(e&&(e<Z||e>G))throw new Error(\"OSC AtomicInt64 value is out of bounds\");var r;return e&&(r=BigInt.asIntN(64,e)),t(this,n,[r])}return c(n,e),a(n,[{key:\"pack\",value:function(){return p(f(n.prototype),\"pack\",this).call(this,\"setBigInt64\",8)}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p(f(n.prototype),\"unpackWithMethod\",this).call(this,t,\"getBigInt64\",8,e)}}])}(x),J=BigInt(\"18446744073709551615\"),K=function(e){function n(e){if(i(this,n),e&&\"bigint\"!=typeof e)throw new Error(\"OSC AtomicUInt64 constructor expects value of type BigInt\");if(e&&(e<0||e>J))throw new Error(\"OSC AtomicUInt64 value is out of bounds\");var r;return e&&(r=BigInt.asUintN(64,e)),t(this,n,[r])}return c(n,e),a(n,[{key:\"pack\",value:function(){return p(f(n.prototype),\"pack\",this).call(this,\"setBigUint64\",8)}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p(f(n.prototype),\"unpackWithMethod\",this).call(this,t,\"getBigUint64\",8,e)}}])}(x),Q=!0,X=!1,Y=null,$=1/0,tt=a((function t(e,n){var r=this;if(i(this,t),this.offset=0,this.address=\"\",this.types=\"\",this.args=[],!O(e)){if(!w(e)&&!k(e))throw new Error(\"OSC Message constructor first argument (address) must be a string or array\");this.address=D(e)}if(!O(n)){if(!k(n))throw new Error(\"OSC Message constructor second argument (args) must be an array\");n.forEach((function(t){return r.add(t.type,t.value)}))}}),[{key:\"add\",value:function(t,e){if(O(t))throw new Error(\"OSC Message needs a valid OSC Atomic Data Type\");\"N\"===t?this.args.push(Y):\"T\"===t?this.args.push(Q):\"F\"===t?this.args.push(X):\"I\"===t?this.args.push($):this.args.push(e),this.types+=t}},{key:\"pack\",value:function(){var t=this;if(0===this.address.length||\"/\"!==this.address[0])throw new Error(\"OSC Message has an invalid address\");var e=new M;if(e.add(new N(this.address)),e.add(new N(\",\".concat(this.types))),this.args.length>0){var n;if(this.args.length>this.types.length)throw new Error(\"OSC Message argument and type tag mismatch\");this.args.forEach((function(r,o){var i=t.types[o];if(\"i\"===i)n=new T(r);else if(\"h\"===i)n=new q(r);else if(\"t\"===i)n=new K(r);else if(\"f\"===i)n=new R(r);else if(\"d\"===i)n=new z(r);else if(\"s\"===i)n=new N(r);else if(\"b\"===i)n=new F(r);else if(\"T\"===i)n=Q;else if(\"F\"===i)n=X;else if(\"N\"===i)n=Y;else{if(\"I\"!==i)throw new Error(\"OSC Message found unknown argument type\");n=$}e.add(n)}))}return e.merge()}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(t instanceof DataView))throw new Error(\"OSC Message expects an instance of type DataView.\");var n=new N;n.unpack(t,e);var r=new N;if(r.unpack(t,n.offset),0===n.value.length||\"/\"!==n.value[0])throw new Error(\"OSC Message found malformed or missing address string\");if(0===r.value.length&&\",\"!==r.value[0])throw new Error(\"OSC Message found malformed or missing type string\");for(var o,i,s=r.offset,a=[],u=1;u<r.value.length;u+=1){if(o=null,\"i\"===(i=r.value[u]))o=new T;else if(\"h\"===i)o=new q;else if(\"t\"===i)o=new K;else if(\"f\"===i)o=new R;else if(\"d\"===i)o=new z;else if(\"s\"===i)o=new N;else if(\"b\"===i)o=new F;else if(\"T\"===i)a.push(Q);else if(\"F\"===i)a.push(X);else if(\"N\"===i)a.push(Y);else{if(\"I\"!==i)throw new Error(\"OSC Message found unsupported argument type\");a.push($)}o&&(s=o.unpack(t,s),a.push(o.value))}return this.offset=s,this.address=n.value,this.types=r.value,this.args=a,this.offset}}]),et=function(e){function n(e){var r,o;i(this,n);for(var s=arguments.length,a=new Array(s>1?s-1:0),u=1;u<s;u++)a[u-1]=arguments[u];return a.length>0&&a[0]instanceof Array&&(o=a.shift()),r=t(this,n,[e,o]),a.length>0&&(r.types=a.map((function(t){return j(t)})).join(\"\"),r.args=a),r}return c(n,e),a(n,[{key:\"add\",value:function(t){p(f(n.prototype),\"add\",this).call(this,j(t),t)}}])}(tt),nt=\"#bundle\",rt=function(){function t(){var e=this;i(this,t),this.offset=0,this.timetag=new _,this.bundleElements=[];for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];r.length>0&&(r[0]instanceof Date||d(r[0])?this.timetag=new _(r[0]):k(r[0])?(r[0].forEach((function(t){e.add(t)})),r.length>1&&(r[1]instanceof Date||d(r[1]))&&(this.timetag=new _(r[1]))):r.forEach((function(t){e.add(t)})))}return a(t,[{key:\"timestamp\",value:function(t){if(!d(t))throw new Error(\"OSC Bundle needs an integer for setting the timestamp\");this.timetag=new _(t)}},{key:\"add\",value:function(e){if(!(e instanceof et||e instanceof t))throw new Error(\"OSC Bundle contains only Messages and Bundles\");this.bundleElements.push(e)}},{key:\"pack\",value:function(){var t=new M;return t.add(new N(nt)),this.timetag||(this.timetag=new _),t.add(this.timetag),this.bundleElements.forEach((function(e){t.add(new T(e.pack().byteLength)),t.add(e)})),t.merge()}},{key:\"unpack\",value:function(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(e instanceof DataView))throw new Error(\"OSC Bundle expects an instance of type DataView\");var r=new N;if(r.unpack(e,n),r.value!==nt)throw new Error(\"OSC Bundle does not contain a valid #bundle head\");var o=new _,i=o.unpack(e,r.offset);for(this.bundleElements=[];i<e.byteLength;){var s=new N,a=new T;i=a.unpack(e,i);var u=void 0;s.unpack(e,i),i=(u=s.value===nt?new t:new et).unpack(e,i),this.bundleElements.push(u)}return this.offset=i,this.timetag=o,this.offset}}])}(),ot=a((function t(e){if(i(this,t),e&&!(e instanceof et||e instanceof rt))throw new Error(\"OSC Packet value has to be Message or Bundle\");this.value=e,this.offset=0}),[{key:\"pack\",value:function(){if(!this.value)throw new Error(\"OSC Packet can not be encoded with empty body\");return this.value.pack()}},{key:\"unpack\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!(t instanceof DataView))throw new Error(\"OSC Packet expects an instance of type DataView\");if(t.byteLength%4!=0)throw new Error(\"OSC Packet byteLength has to be a multiple of four\");var n,r=new N;return r.unpack(t,e),(n=r.value===nt?new rt:new et).unpack(t,e),this.offset=n.offset,this.value=n,this.offset}}]),it={discardLateMessages:!1},st=a((function t(e){i(this,t),this.options=r(r({},it),e),this.addressHandlers=[],this.eventHandlers={open:[],error:[],close:[]},this.uuid=0}),[{key:\"dispatch\",value:function(t,e){var n=this;if(!(t instanceof ot))throw new Error(\"OSC EventHander dispatch() accepts only arguments of type Packet\");if(!t.value)throw new Error(\"OSC EventHander dispatch() can't read empty Packets\");if(t.value instanceof rt){var r=t.value;return r.bundleElements.forEach((function(t){if(t instanceof rt){if(r.timetag.value.timestamp()<t.timetag.value.timestamp())throw new Error(\"OSC Bundle timestamp is older than the timestamp of enclosed Bundles\");return n.dispatch(new ot(t))}if(t instanceof et){var o=t;return n.notify(o.address,o,r.timetag.value.timestamp(),e)}throw new Error(\"OSC EventHander dispatch() can't dispatch unknown Packet value\")}))}if(t.value instanceof et){var o=t.value;return this.notify(o.address,o,0,e)}throw new Error(\"OSC EventHander dispatch() can't dispatch unknown Packet value\")}},{key:\"call\",value:function(t,e,n){var r=!1;if(w(t)&&t in this.eventHandlers)return this.eventHandlers[t].forEach((function(t){t.callback(e,n),r=!0})),r;var o=Object.keys(this.addressHandlers),i=this.addressHandlers;return o.forEach((function(o){var s=!1,a=new RegExp(B(D(t)),\"g\");if(a.test(o)&&o.length===a.lastIndex&&(s=!0),!s){var u=new RegExp(B(D(o)),\"g\");u.test(t)&&t.length===u.lastIndex&&(s=!0)}s&&i[o].forEach((function(t){t.callback(e,n),r=!0}))})),r}},{key:\"notify\",value:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];if(0===e.length)throw new Error(\"OSC EventHandler can not be called without any argument\");try{if(e[0]instanceof ot)return this.dispatch(e[0],e[1]);if(e[0]instanceof rt||e[0]instanceof et)return this.dispatch(new ot(e[0]),e[1]);if(!w(e[0])){var r=new ot;return r.unpack(I(e[0])),this.dispatch(r,e[1])}var o=e[0],i=null;e.length>1&&(i=e[1]);var s=null;if(e.length>2)if(d(e[2]))s=e[2];else{if(!(e[2]instanceof Date))throw new Error(\"OSC EventHandler timestamp has to be a number or Date\");s=e[2].getTime()}var a=null;if(e.length>=3&&(a=e[3]),s){var u=Date.now();if(u>s&&!this.options.discardLateMessages)return this.call(o,i,a);var c=this;return setTimeout((function(){c.call(o,i,a)}),s-u),!0}return this.call(o,i,a)}catch(t){return this.notify(\"error\",t),!1}}},{key:\"on\",value:function(t,e){if(!w(t)&&!k(t))throw new Error(\"OSC EventHandler accepts only strings or arrays for address patterns\");if(!m(e))throw new Error(\"OSC EventHandler callback has to be a function\");this.uuid+=1;var n={id:this.uuid,callback:e};if(w(t)&&t in this.eventHandlers)return this.eventHandlers[t].push(n),this.uuid;var r=D(t);return r in this.addressHandlers||(this.addressHandlers[r]=[]),this.addressHandlers[r].push(n),this.uuid}},{key:\"off\",value:function(t,e){if(!w(t)&&!k(t))throw new Error(\"OSC EventHandler accepts only strings or arrays for address patterns\");if(!d(e))throw new Error(\"OSC EventHandler subscription id has to be a number\");var n,r;return w(t)&&t in this.eventHandlers?(n=t,r=this.eventHandlers):(n=D(t),r=this.addressHandlers),n in r&&r[n].some((function(t,o){return t.id===e&&(r[n].splice(o,1),!0)}))}}]),at=a((function t(){if(i(this,t),this.constructor===t)throw new Error(\"Plugin is an abstract class. Please create or use an implementation!\")}),[{key:\"status\",value:function(){throw new Error(\"Abstract method!\")}},{key:\"open\",value:function(){throw new Error(\"Abstract method!\")}},{key:\"close\",value:function(){throw new Error(\"Abstract method!\")}},{key:\"send\",value:function(t){throw new Error(\"Abstract method!\")}}]),ut=0,ct=1,ft=2,lt=3,ht=function(e){function n(){throw i(this,n),t(this,n),new Error(\"DatagramPlugin can not be used in browser context\")}return c(n,e),a(n,[{key:\"registerNotify\",value:function(t){this.notify=t}},{key:\"status\",value:function(){return this.socketStatus}},{key:\"open\",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r(r({},this.options.open),e),o=n.port,i=n.exclusive;this.socketStatus=ut,this.socket.bind({address:n.host,port:o,exclusive:i},(function(){t.socketStatus=ct,t.notify(\"open\")}))}},{key:\"close\",value:function(){var t=this;this.socketStatus=ft,this.socket.close((function(){t.socketStatus=lt,t.notify(\"close\")}))}},{key:\"send\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=r(r({},this.options.send),e),o=n.port,i=n.host;this.socket.send(Buffer.from(t),0,t.byteLength,o,i)}}])}(at);var pt=\"undefined\"!=typeof WebSocket?WebSocket:\"undefined\"!=typeof MozWebSocket?MozWebSocket:\"undefined\"!=typeof global?global.WebSocket||global.MozWebSocket:\"undefined\"!=typeof window?window.WebSocket||window.MozWebSocket:\"undefined\"!=typeof self?self.WebSocket||self.MozWebSocket:void 0,dt=void 0,vt=0,wt=1,yt=2,gt=3,kt={udpServer:{host:\"localhost\",port:41234,exclusive:!1},udpClient:{host:\"localhost\",port:41235},wsServer:{host:\"localhost\",port:8080},receiver:\"ws\"};function bt(t,e){return r(r(r(r({},kt),t),e),{},{udpServer:r(r(r({},kt.udpServer),t.udpServer),e.udpServer),udpClient:r(r(r({},kt.udpClient),t.udpClient),e.udpClient),wsServer:r(r(r({},kt.wsServer),t.wsServer),e.wsServer)})}var mt=function(e){function n(){throw i(this,n),t(this,n),new Error(\"BridgePlugin can not be used in browser context\")}return c(n,e),a(n,[{key:\"registerNotify\",value:function(t){this.notify=t}},{key:\"status\",value:function(){return this.socketStatus}},{key:\"open\",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=bt(this.options,e);this.socketStatus=vt,this.socket.bind({address:n.udpServer.host,port:n.udpServer.port,exclusive:n.udpServer.exclusive},(function(){var e={};n.wsServer.server?e.server=n.wsServer.server:e=n.wsServer,t.websocket=new dt(e),t.websocket.binaryType=\"arraybuffer\",t.websocket.on(\"listening\",(function(){t.socketStatus=wt,t.notify(\"open\")})),t.websocket.on(\"error\",(function(e){t.notify(\"error\",e)})),t.websocket.on(\"connection\",(function(e){e.on(\"message\",(function(e,n){t.send(e,{receiver:\"udp\"}),t.notify(new Uint8Array(e),n)}))}))}))}},{key:\"close\",value:function(){var t=this;this.socketStatus=yt,this.socket.close((function(){t.websocket.close((function(){t.socketStatus=gt,t.notify(\"close\")}))}))}},{key:\"send\",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=bt(this.options,e),r=n.receiver;if(\"udp\"===r){var o=t instanceof Buffer?t:Buffer.from(t);this.socket.send(o,0,o.byteLength,n.udpClient.port,n.udpClient.host)}else{if(\"ws\"!==r)throw new Error(\"BridgePlugin can not send message to unknown receiver\");this.websocket.clients.forEach((function(e){e.send(t,{binary:!0})}))}}}])}(at),St=-1,Et=0,Ot=1,Ct=2,Pt=3,At={host:\"localhost\",port:8080,secure:!1,protocol:[]},It=function(e){function n(e){var o;if(i(this,n),o=t(this,n),!pt)throw new Error(\"WebsocketClientPlugin can't find a WebSocket class\");return o.options=r(r({},At),e),o.socket=null,o.socketStatus=St,o.notify=function(){},o}return c(n,e),a(n,[{key:\"registerNotify\",value:function(t){this.notify=t}},{key:\"status\",value:function(){return this.socketStatus}},{key:\"open\",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r(r({},this.options),e),o=n.port,i=n.host,s=n.secure,a=n.protocol;this.socket&&this.close();var u=s?\"wss\":\"ws\",c={address:i,family:u,port:o,size:0};this.socket=new pt(\"\".concat(u,\"://\").concat(i,\":\").concat(o),a),this.socket.binaryType=\"arraybuffer\",this.socketStatus=Et,this.socket.onopen=function(){t.socketStatus=Ot,t.notify(\"open\")},this.socket.onclose=function(){t.socketStatus=Pt,t.notify(\"close\")},this.socket.onerror=function(e){t.notify(\"error\",e)},this.socket.onmessage=function(e){t.notify(e.data,c)}}},{key:\"close\",value:function(){this.socketStatus=Ct,this.socket.close()}},{key:\"send\",value:function(t){this.socket.send(t)}}])}(at),jt=0,Dt=1,Bt=2,Mt=3,xt=function(e){function n(e){throw i(this,n),t(this,n),new Error(\"WebsocketServerPlugin can not be used in browser context\")}return c(n,e),a(n,[{key:\"registerNotify\",value:function(t){this.notify=t}},{key:\"status\",value:function(){return this.socketStatus}},{key:\"open\",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=r(r({},this.options),e),o=n.port,i=n.host,s={address:i,family:\"wsserver\",port:o,size:0};this.socket&&this.close(),n.server?this.socket=new dt({server:n.server}):this.socket=new dt({host:i,port:o}),this.socket.binaryType=\"arraybuffer\",this.socketStatus=jt,this.socket.on(\"listening\",(function(){t.socketStatus=Dt,t.notify(\"open\")})),this.socket.on(\"error\",(function(e){t.notify(\"error\",e)})),this.socket.on(\"connection\",(function(e){e.on(\"message\",(function(e){t.notify(new Uint8Array(e),s)}))}))}},{key:\"close\",value:function(){var t=this;this.socketStatus=Bt,this.socket.close((function(){t.socketStatus=Mt,t.notify(\"close\")}))}},{key:\"send\",value:function(t){this.socket.clients.forEach((function(e){e.send(t,{binary:!0})}))}}])}(at),Tt={discardLateMessages:!1},Ht=a((function t(e){if(i(this,t),e&&!b(e))throw new Error(\"OSC options argument has to be an object.\");this.options=r(r({},Tt),e),this.options.plugin||(this.options.plugin=new It),this.eventHandler=new st({discardLateMessages:this.options.discardLateMessages});var n=this.eventHandler;this.options.plugin&&this.options.plugin.registerNotify&&this.options.plugin.registerNotify((function(){return n.notify.apply(n,arguments)}))}),[{key:\"on\",value:function(t,e){if(!w(t)||!m(e))throw new Error(\"OSC on() needs event- or address string and callback function\");return this.eventHandler.on(t,e)}},{key:\"off\",value:function(t,e){if(!w(t)||!d(e))throw new Error(\"OSC off() needs string and number (subscriptionId) to unsubscribe\");return this.eventHandler.off(t,e)}},{key:\"open\",value:function(t){if(t&&!b(t))throw new Error(\"OSC open() options argument needs to be an object\");if(!this.options.plugin||!m(this.options.plugin.open))throw new Error(\"OSC Plugin API #open is not implemented!\");return this.options.plugin.open(t)}},{key:\"status\",value:function(){if(!this.options.plugin||!m(this.options.plugin.status))throw new Error(\"OSC Plugin API #status is not implemented!\");return this.options.plugin.status()}},{key:\"close\",value:function(){if(!this.options.plugin||!m(this.options.plugin.close))throw new Error(\"OSC Plugin API #close is not implemented!\");return this.options.plugin.close()}},{key:\"send\",value:function(t,e){if(!this.options.plugin||!m(this.options.plugin.send))throw new Error(\"OSC Plugin API #send is not implemented!\");if(!(t instanceof tt||t instanceof et||t instanceof rt||t instanceof ot))throw new Error(\"OSC send() needs Messages, Bundles or Packets\");if(e&&!b(e))throw new Error(\"OSC send() options argument has to be an object\");return this.options.plugin.send(t.pack(),e)}}]);return Ht.STATUS={IS_NOT_INITIALIZED:-1,IS_CONNECTING:0,IS_OPEN:1,IS_CLOSING:2,IS_CLOSED:3},Ht.Packet=ot,Ht.Bundle=rt,Ht.Message=et,Ht.TypedMessage=tt,Ht.Plugin=at,Ht.DatagramPlugin=ht,Ht.WebsocketClientPlugin=It,Ht.WebsocketServerPlugin=xt,Ht.BridgePlugin=mt,Ht}));\n//# sourceMappingURL=osc.min.js.map\n","/**\n * Check if given object is an integer number\n * @param {*} n\n * @return {boolean}\n */\nexport function isInt(n) {\n  return Number(n) === n && n % 1 === 0\n}\n\n/**\n * Check if given object is a float number\n * @param {*} n\n * @return {boolean}\n */\nexport function isFloat(n) {\n  return Number(n) === n && n % 1 !== 0\n}\n\n/**\n * Check if given object is a number\n * @param {*} n\n * @return {boolean}\n */\nexport function isNumber(n) {\n  return Number(n) === n\n}\n\n/**\n * Check if given object is a string\n * @param {*} n\n * @return {boolean}\n */\nexport function isString(n) {\n  return typeof n === 'string'\n}\n\n/**\n * Check if given object is a boolean\n * @param {*} n\n * @return {boolean}\n */\nexport function isBoolean(n) {\n  return typeof n === 'boolean'\n}\n\n/**\n * Check if given object is infinity constant\n * @param {*} n\n * @return {boolean}\n */\nexport function isInfinity(n) {\n  return n === Infinity\n}\n\n/**\n * Check if given object is an array\n * @param {*} n\n * @return {boolean}\n */\nexport function isArray(n) {\n  return Object.prototype.toString.call(n) === '[object Array]'\n}\n\n/**\n * Check if given object is an object\n * @param {*} n\n * @return {boolean}\n */\nexport function isObject(n) {\n  return Object.prototype.toString.call(n) === '[object Object]'\n}\n\n/**\n * Check if given object is a function\n * @param {*} n\n * @return {boolean}\n */\nexport function isFunction(n) {\n  return typeof n === 'function'\n}\n\n/**\n * Check if given object is a Uint8Array\n * @param {*} n\n * @return {boolean}\n */\nexport function isBlob(n) {\n  return n instanceof Uint8Array\n}\n\n/**\n * Check if given object is a Date\n * @param {*} n\n * @return {boolean}\n */\nexport function isDate(n) {\n  return n instanceof Date\n}\n\n/**\n * Check if given object is undefined\n * @param {*} n\n * @return {boolean}\n */\nexport function isUndefined(n) {\n  return typeof n === 'undefined'\n}\n\n/**\n * Check if given object is null\n * @param {*} n\n * @return {boolean}\n */\nexport function isNull(n) {\n  return n === null\n}\n\n/**\n * Return the next multiple of four\n * @param {number} n\n */\nexport function pad(n) {\n  return (n + 3) & ~0x03\n}\n\n/**\n * Checks if environment provides a feature\n * @param {string} name Name of needed feature\n * @return {boolean}\n */\nexport function hasProperty(name) {\n  return Object.prototype.hasOwnProperty.call(\n    (typeof global !== 'undefined' ? global : window), // eslint-disable-line no-undef\n    name,\n  )\n}\n\n/**\n * Wrap binary data in DataView\n * @param {*} obj\n * @return {DataView}\n */\nexport function dataView(obj) {\n  if (obj.buffer) {\n    return new DataView(obj.buffer)\n  } else if (obj instanceof ArrayBuffer) {\n    return new DataView(obj)\n  }\n\n  return new DataView(new Uint8Array(obj))\n}\n","import {\n  isArray,\n  isBlob,\n  isBoolean,\n  isFloat,\n  isInfinity,\n  isInt,\n  isNull,\n  isString,\n} from './utils'\n\n/**\n * Checks type of given object and returns the regarding OSC\n * Type tag character\n * @param {*} item Any object\n * @return {string} OSC Type tag character\n */\nexport function typeTag(item) {\n  if (isInt(item)) {\n    return 'i'\n  } else if (isFloat(item)) {\n    return 'f'\n  } else if (isString(item)) {\n    return 's'\n  } else if (isBlob(item)) {\n    return 'b'\n  } else if (isBoolean(item)) {\n    return item ? 'T' : 'F'\n  } else if (isNull(item)) {\n    return 'N'\n  } else if (isInfinity(item)) {\n    return 'I'\n  }\n\n  throw new Error('OSC typeTag() found unknown value type')\n}\n\n/**\n * Sanitizes an OSC-ready Address Pattern\n * @param {string[]|string} obj Address as string or array of strings\n * @return {string} Corrected address string\n *\n * @example\n * // all calls return '/test/path' string:\n * prepareAddress('test/path')\n * prepareAddress('/test/path/')\n * prepareAddress([test, path])\n */\nexport function prepareAddress(obj) {\n  let address = ''\n\n  if (isArray(obj)) {\n    return `/${obj.join('/')}`\n  } else if (isString(obj)) {\n    address = obj\n\n    // remove slash at ending of address\n    if (address.length > 1 && address[address.length - 1] === '/') {\n      address = address.slice(0, address.length - 1)\n    }\n\n    // add slash at beginning of address\n    if (address.length > 1 && address[0] !== '/') {\n      address = `/${address}`\n    }\n\n    return address\n  }\n\n  throw new Error('OSC prepareAddress() needs addresses of type array or string')\n}\n\n/**\n * Make an OSC address pattern javascript-regex-ready\n * @param {string} str OSC address pattern\n * @return {string} Javascript RegEx string\n */\nexport function prepareRegExPattern(str) {\n  let pattern\n\n  if (!(isString(str))) {\n    throw new Error('OSC prepareRegExPattern() needs strings')\n  }\n\n  pattern = str.replace(/\\./g, '\\\\.')\n  pattern = pattern.replace(/\\(/g, '\\\\(')\n  pattern = pattern.replace(/\\)/g, '\\\\)')\n\n  pattern = pattern.replace(/\\{/g, '(')\n  pattern = pattern.replace(/\\}/g, ')')\n  pattern = pattern.replace(/,/g, '|')\n\n  pattern = pattern.replace(/\\[!/g, '[^')\n\n  pattern = pattern.replace(/\\?/g, '.')\n  pattern = pattern.replace(/\\*/g, '.*')\n\n  return pattern\n}\n\n/**\n * Holds a list of items and helps to merge them\n * into a single array of packed binary data\n */\nexport default class EncodeHelper {\n  /**\n   * Create a new EncodeHelper instance\n   */\n  constructor() {\n    /** @type {array} data */\n    this.data = []\n    /** @type {number} byteLength */\n    this.byteLength = 0\n  }\n\n  /**\n   * Packs an item and adds it to the list\n   * @param {*} item Any object\n   * @return {EncodeHelper}\n   */\n  add(item) {\n    // Skip encoding items which do not need a payload as they are constants\n    if (isBoolean(item) || isInfinity(item) || isNull(item)) {\n      return this\n    }\n\n    const buffer = item.pack()\n    this.byteLength += buffer.byteLength\n    this.data.push(buffer)\n\n    return this\n  }\n\n  /**\n   * Merge all added items into one Uint8Array\n   * @return {Uint8Array} Merged binary data array of all items\n   */\n  merge() {\n    const result = new Uint8Array(this.byteLength)\n    let offset = 0\n\n    this.data.forEach((data) => {\n      result.set(data, offset)\n      offset += data.byteLength\n    })\n\n    return result\n  }\n}\n","import { isUndefined } from './common/utils'\n\n/**\n * Base class for OSC Atomic Data Types\n */\nexport default class Atomic {\n  /**\n   * Create an Atomic instance\n   * @param {*} [value] Initial value of any type\n   */\n  constructor(value) {\n    /** @type {*} value */\n    this.value = value\n    /** @type {number} offset */\n    this.offset = 0\n  }\n\n  /**\n   * Interpret the given value of this entity as packed binary data\n   * @param {string} method The DataView method to write to the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @return {Uint8Array} Packed binary data\n   */\n  pack(method, byteLength) {\n    if (!(method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be packed without given method or byteLength')\n    }\n\n    const data = new Uint8Array(byteLength)\n    const dataView = new DataView(data.buffer)\n\n    if (isUndefined(this.value)) {\n      throw new Error('OSC Atomic cant\\'t be encoded with empty value')\n    }\n\n    // use DataView to write to ArrayBuffer\n    dataView[method](this.offset, this.value, false)\n\n    // always return binary Uint8Array after packing\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView according to the given format\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {string} method The DataView method to read the format from the ArrayBuffer\n   * @param {number} byteLength Size of array in bytes\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpackWithMethod(dataView, method, byteLength, initialOffset = 0) {\n    if (!(dataView && method && byteLength)) {\n      throw new Error('OSC Atomic cant\\'t be unpacked without given dataView, method or byteLength')\n    }\n\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Atomic expects an instance of type DataView')\n    }\n\n    // use DataView to read from ArrayBuffer and add offset\n    this.value = dataView[method](initialOffset, false)\n    this.offset = initialOffset + byteLength\n\n    // always return offset number after unpacking\n    return this.offset\n  }\n}\n","import { isInt } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian two's complement integer OSC Atomic Data Type\n */\nexport default class AtomicInt32 extends Atomic {\n  /**\n   * Create an AtomicInt32 instance\n   * @param {number} [value] Initial integer value\n   */\n  constructor(value) {\n    if (value && !isInt(value)) {\n      throw new Error('OSC AtomicInt32 constructor expects value of type number')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setInt32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Int32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpackWithMethod(dataView, 'getInt32', 4, initialOffset)\n  }\n}\n","import {\n  hasProperty,\n  isString,\n  isUndefined,\n  pad,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** Slice size of large strings for fallback method */\nconst STR_SLICE_SIZE = 65537\n\n/** Text encoding format */\nconst STR_ENCODING = 'utf-8'\n\n/**\n * Helper method to decode a string using different methods depending on environment\n * @param {number[]} charCodes Array of char codes\n * @return {string} Decoded string\n */\nfunction charCodesToString(charCodes) {\n  // Use these methods to be able to convert large strings\n  if (hasProperty('Buffer')) {\n    return Buffer.from(charCodes).toString(STR_ENCODING)\n  } else if (hasProperty('TextDecoder')) {\n    return new TextDecoder(STR_ENCODING) // eslint-disable-line no-undef\n      .decode(new Int8Array(charCodes))\n  }\n\n  // Fallback method\n  let str = ''\n\n  for (let i = 0; i < charCodes.length; i += STR_SLICE_SIZE) {\n    str += String.fromCharCode.apply(\n      null,\n      charCodes.slice(i, i + STR_SLICE_SIZE),\n    )\n  }\n\n  return str\n}\n\n/**\n * A sequence of non-null ASCII characters OSC Atomic Data Type\n */\nexport default class AtomicString extends Atomic {\n  /**\n   * Create an AtomicString instance\n   * @param {string} [value] Initial string value\n   */\n  constructor(value) {\n    if (value && !isString(value)) {\n      throw new Error('OSC AtomicString constructor expects value of type string')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given string as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicString can not be encoded with empty value')\n    }\n\n    // add 0-3 null characters for total number of bits a multiple of 32\n    const terminated = `${this.value}\\u0000`\n    const byteLength = pad(terminated.length)\n\n    const buffer = new Uint8Array(byteLength)\n\n    for (let i = 0; i < terminated.length; i += 1) {\n      buffer[i] = terminated.charCodeAt(i)\n    }\n\n    return buffer\n  }\n\n  /**\n   * Unpack binary data from DataView and read a string\n   * @param {DataView} dataView The DataView holding the binary representation of the string\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicString expects an instance of type DataView')\n    }\n\n    let offset = initialOffset\n    let charcode\n    const charCodes = []\n\n    for (; offset < dataView.byteLength; offset += 1) {\n      charcode = dataView.getUint8(offset)\n\n      // check for terminating null character\n      if (charcode !== 0) {\n        charCodes.push(charcode)\n      } else {\n        offset += 1\n        break\n      }\n    }\n\n    if (offset === dataView.length) {\n      throw new Error('OSC AtomicString found a malformed OSC string')\n    }\n\n    /** @type {number} offset */\n    this.offset = pad(offset)\n    /** @type {string} value */\n    this.value = charCodesToString(charCodes)\n\n    return this.offset\n  }\n}\n","import {\n  isDate,\n  isInt,\n  isUndefined,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/** 70 years in seconds */\nexport const SECONDS_70_YEARS = 2208988800\n/** 2^32 */\nexport const TWO_POWER_32 = 4294967296\n\n/**\n * Timetag helper class for representing NTP timestamps\n * and conversion between them and javascript representation\n */\nexport class Timetag {\n  /**\n   * Create a Timetag instance\n   * @param {number} [seconds=0] Initial NTP *seconds* value\n   * @param {number} [fractions=0] Initial NTP *fractions* value\n   */\n  constructor(seconds = 0, fractions = 0) {\n    if (!(isInt(seconds) && isInt(fractions))) {\n      throw new Error('OSC Timetag constructor expects values of type integer number')\n    }\n\n    /** @type {number} seconds */\n    this.seconds = seconds\n    /** @type {number} fractions */\n    this.fractions = fractions\n  }\n\n  /**\n   * Converts from NTP to JS representation and back\n   * @param {number} [milliseconds] Converts from JS milliseconds to NTP.\n   * Leave empty for converting from NTP to JavaScript representation\n   * @return {number} Javascript timestamp\n   */\n  timestamp(milliseconds) {\n    let seconds\n\n    if (typeof milliseconds === 'number') {\n      seconds = milliseconds / 1000\n      const rounded = Math.floor(seconds)\n\n      this.seconds = rounded + SECONDS_70_YEARS\n      this.fractions = Math.round(TWO_POWER_32 * (seconds - rounded))\n\n      return milliseconds\n    }\n\n    seconds = this.seconds - SECONDS_70_YEARS\n    return (seconds + Math.round(this.fractions / TWO_POWER_32)) * 1000\n  }\n}\n\n/**\n * 64-bit big-endian fixed-point time tag, semantics\n * defined below OSC Atomic Data Type\n */\nexport default class AtomicTimetag extends Atomic {\n  /**\n   * Create a AtomicTimetag instance\n   * @param {number|Timetag|Date} [value] Initial date, leave empty if\n   * you want it to be the current date\n   */\n  constructor(value = Date.now()) {\n    let timetag = new Timetag()\n\n    if (value instanceof Timetag) {\n      timetag = value\n    } else if (isInt(value)) {\n      timetag.timestamp(value)\n    } else if (isDate(value)) {\n      timetag.timestamp(value.getTime())\n    }\n\n    super(timetag)\n  }\n\n  /**\n   * Interpret the given timetag as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicTimetag can not be encoded with empty value')\n    }\n\n    const { seconds, fractions } = this.value\n    const data = new Uint8Array(8)\n    const dataView = new DataView(data.buffer)\n\n    dataView.setInt32(0, seconds, false)\n    dataView.setInt32(4, fractions, false)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a timetag\n   * @param {DataView} dataView The DataView holding the binary representation of the timetag\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicTimetag expects an instance of type DataView')\n    }\n\n    const seconds = dataView.getUint32(initialOffset, false)\n    const fractions = dataView.getUint32(initialOffset + 4, false)\n\n    /** @type {Timetag} value */\n    this.value = new Timetag(seconds, fractions)\n    /** @type {number} offset */\n    this.offset = initialOffset + 8\n\n    return this.offset\n  }\n}\n","import {\n  isBlob,\n  isUndefined,\n  pad,\n} from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 8-bit bytes of arbitrary binary data OSC Atomic Data Type\n */\nexport default class AtomicBlob extends Atomic {\n  /**\n   * Create an AtomicBlob instance\n   * @param {Uint8Array} [value] Binary data\n   */\n  constructor(value) {\n    if (value && !isBlob(value)) {\n      throw new Error('OSC AtomicBlob constructor expects value of type Uint8Array')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given blob as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (isUndefined(this.value)) {\n      throw new Error('OSC AtomicBlob can not be encoded with empty value')\n    }\n\n    const byteLength = pad(this.value.byteLength)\n    const data = new Uint8Array(byteLength + 4)\n    const dataView = new DataView(data.buffer)\n\n    // an int32 size count\n    dataView.setInt32(0, this.value.byteLength, false)\n    // followed by 8-bit bytes of arbitrary binary data\n    data.set(this.value, 4)\n\n    return data\n  }\n\n  /**\n   * Unpack binary data from DataView and read a blob\n   * @param {DataView} dataView The DataView holding the binary representation of the blob\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC AtomicBlob expects an instance of type DataView')\n    }\n\n    const byteLength = dataView.getInt32(initialOffset, false)\n\n    /** @type {Uint8Array} value */\n    this.value = new Uint8Array(dataView.buffer, initialOffset + 4, byteLength)\n    /** @type {number} offset */\n    this.offset = pad(initialOffset + 4 + byteLength)\n\n    return this.offset\n  }\n}\n","import { isNumber } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 32-bit big-endian IEEE 754 floating point number OSC Atomic Data Type\n */\nexport default class AtomicFloat32 extends Atomic {\n  /**\n   * Create an AtomicFloat32 instance\n   * @param {number} [value] Float number\n   */\n  constructor(value) {\n    if (value && !isNumber(value)) {\n      throw new Error('OSC AtomicFloat32 constructor expects value of type float')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat32', 4)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float32 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpackWithMethod(dataView, 'getFloat32', 4, initialOffset)\n  }\n}\n","import { isNumber } from '../common/utils'\n\nimport Atomic from '../atomic'\n\n/**\n * 64-bit big-endian IEEE 754 floating point number OSC Atomic Data Type\n */\nexport default class AtomicFloat64 extends Atomic {\n  /**\n   * Create an AtomicFloat64 instance\n   * @param {number} [value] Float number\n   */\n  constructor(value) {\n    if (value && !isNumber(value)) {\n      throw new Error('OSC AtomicFloat64 constructor expects value of type float')\n    }\n\n    super(value)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setFloat64', 8)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Float64 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpackWithMethod(dataView, 'getFloat64', 8, initialOffset)\n  }\n}\n","import Atomic from '../atomic'\n\nconst MAX_INT64 = BigInt('9223372036854775807')\nconst MIN_INT64 = BigInt('-9223372036854775808')\n\n/**\n * 64-bit big-endian two's complement integer OSC Atomic Data Type\n */\nexport default class AtomicInt64 extends Atomic {\n  /**\n   * Create an AtomicInt64 instance\n   * @param {number} [value] Initial integer value\n   */\n  constructor(value) {\n    if (value && typeof value !== 'bigint') {\n      throw new Error('OSC AtomicInt64 constructor expects value of type BigInt')\n    }\n\n    if (value && (value < MIN_INT64 || value > MAX_INT64)) {\n      throw new Error('OSC AtomicInt64 value is out of bounds')\n    }\n\n    let tmp\n    if (value) {\n      tmp = BigInt.asIntN(64, value)\n    }\n\n    super(tmp)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setBigInt64', 8)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a Int64 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpackWithMethod(dataView, 'getBigInt64', 8, initialOffset)\n  }\n}\n","import Atomic from '../atomic'\n\nconst MAX_UINT64 = BigInt('18446744073709551615')\n\n/**\n * Unsigned 64-bit big-endian two's complement integer OSC Atomic Data Type\n */\nexport default class AtomicUInt64 extends Atomic {\n  /**\n   * Create an AtomicUInt64 instance\n   * @param {number} [value] Initial integer value\n   */\n  constructor(value) {\n    if (value && typeof value !== 'bigint') {\n      throw new Error('OSC AtomicUInt64 constructor expects value of type BigInt')\n    }\n\n    if (value && (value < 0 || value > MAX_UINT64)) {\n      throw new Error('OSC AtomicUInt64 value is out of bounds')\n    }\n\n    let tmp\n    if (value) {\n      tmp = BigInt.asUintN(64, value)\n    }\n\n    super(tmp)\n  }\n\n  /**\n   * Interpret the given number as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    return super.pack('setBigUint64', 8)\n  }\n\n  /**\n   * Unpack binary data from DataView and read a UInt64 number\n   * @param {DataView} dataView The DataView holding the binary representation of the value\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    return super.unpackWithMethod(dataView, 'getBigUint64', 8, initialOffset)\n  }\n}\n","/**\n * Extended boolean type without data representing \"True\"\n */\nexport const VALUE_TRUE = true\n\n/**\n * Extended boolean type without data representing \"False\"\n */\nexport const VALUE_FALSE = false\n\n/**\n * Extended type without data representing \"None\"\n * @type {null}\n */\nexport const VALUE_NONE = null\n\n/**\n * Extended type without data representing \"Infinity\"\n */\nexport const VALUE_INFINITY = Infinity\n","import {\n  isArray,\n  isString,\n  isUndefined,\n} from './common/utils'\n\nimport Helper, { typeTag, prepareAddress } from './common/helpers'\n\nimport AtomicBlob from './atomic/blob'\nimport AtomicFloat32 from './atomic/float32'\nimport AtomicFloat64 from './atomic/float64'\nimport AtomicInt32 from './atomic/int32'\nimport AtomicInt64 from './atomic/int64'\nimport AtomicUInt64 from './atomic/uint64'\nimport AtomicString from './atomic/string'\nimport {\n  VALUE_NONE, VALUE_TRUE, VALUE_FALSE, VALUE_INFINITY,\n} from './atomic/constant'\n\n/**\n * A TypedMessage consists of an OSC address and an optional array of typed OSC arguments.\n *\n * @typedef {'i'|'f'|'s'|'b'|'h'|'t'|'d'|'T'|'F'|'N'|'I'} MessageArgType\n *\n * - `i` - int32\n * - `f` - float32\n * - `s` - string\n * - `b` - blob\n * - `h` - int64\n * - `t` - uint64\n * - `d` - double\n * - `T` - True (no argument data)\n * - `F` - False (no argument data)\n * - `N` - Nil (no argument data)\n * - `I` - Infinitum (no argument data)\n *\n * @typedef {number|string|Blob|VALUE_TRUE|VALUE_FALSE|VALUE_NONE|VALUE_INFINITY} MessageArgValue\n *\n * @typedef {object} MessageArgObject\n * @property {MessageArgType} type\n * @property {MessageArgValue} value\n *\n * @example\n * const messageArgObject = {\n *   type: 'i', value: 123\n * }\n */\nexport class TypedMessage {\n  /**\n   * Create a TypedMessage instance\n   * @param {string[]|string} address Address\n   * @param {MessageArgValue[]} args Arguments\n   *\n   * @example\n   * const message = new TypedMessage(['test', 'path'])\n   * message.add('d', 123.123456789)\n   * message.add('s', 'hello')\n   *\n   * @example\n   * const message = new TypedMessage('/test/path', [\n   *   { type: 'i', value: 123 },\n   *   { type: 'd', value: 123.123 },\n   *   { type: 'h', value: 0xFFFFFFn },\n   *   { type: 'T', value: null },\n   * ])\n   */\n  constructor(address, args) {\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n    /** @type {string} address */\n    this.address = ''\n    /** @type {string} types */\n    this.types = ''\n    /** @type {MessageArgValue[]} args */\n    this.args = []\n\n    if (!isUndefined(address)) {\n      if (!(isString(address) || isArray(address))) {\n        throw new Error('OSC Message constructor first argument (address) must be a string or array')\n      }\n      this.address = prepareAddress(address)\n    }\n\n    if (!isUndefined(args)) {\n      if (!isArray(args)) {\n        throw new Error('OSC Message constructor second argument (args) must be an array')\n      }\n      args.forEach((item) => this.add(item.type, item.value))\n    }\n  }\n\n  /**\n   * Add an OSC Atomic Data Type to the list of elements\n   * @param {MessageArgType} type\n   * @param {MessageArgValue} item\n   */\n  add(type, item) {\n    if (isUndefined(type)) {\n      throw new Error('OSC Message needs a valid OSC Atomic Data Type')\n    }\n\n    if (type === 'N') {\n      this.args.push(VALUE_NONE)\n    } else if (type === 'T') {\n      this.args.push(VALUE_TRUE)\n    } else if (type === 'F') {\n      this.args.push(VALUE_FALSE)\n    } else if (type === 'I') {\n      this.args.push(VALUE_INFINITY)\n    } else {\n      this.args.push(item)\n    }\n\n    this.types += type\n  }\n\n  /**\n   * Interpret the Message as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    if (this.address.length === 0 || this.address[0] !== '/') {\n      throw new Error('OSC Message has an invalid address')\n    }\n\n    const encoder = new Helper()\n\n    // OSC Address Pattern and Type string\n    encoder.add(new AtomicString(this.address))\n    encoder.add(new AtomicString(`,${this.types}`))\n\n    // followed by zero or more OSC Arguments\n    if (this.args.length > 0) {\n      let argument\n\n      if (this.args.length > this.types.length) {\n        throw new Error('OSC Message argument and type tag mismatch')\n      }\n\n      this.args.forEach((value, index) => {\n        const type = this.types[index]\n        if (type === 'i') {\n          argument = new AtomicInt32(value)\n        } else if (type === 'h') {\n          argument = new AtomicInt64(value)\n        } else if (type === 't') {\n          argument = new AtomicUInt64(value)\n        } else if (type === 'f') {\n          argument = new AtomicFloat32(value)\n        } else if (type === 'd') {\n          argument = new AtomicFloat64(value)\n        } else if (type === 's') {\n          argument = new AtomicString(value)\n        } else if (type === 'b') {\n          argument = new AtomicBlob(value)\n        } else if (type === 'T') {\n          argument = VALUE_TRUE\n        } else if (type === 'F') {\n          argument = VALUE_FALSE\n        } else if (type === 'N') {\n          argument = VALUE_NONE\n        } else if (type === 'I') {\n          argument = VALUE_INFINITY\n        } else {\n          throw new Error('OSC Message found unknown argument type')\n        }\n\n        encoder.add(argument)\n      })\n    }\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Message\n   * @param {DataView} dataView The DataView holding the binary representation of a Message\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Message expects an instance of type DataView.')\n    }\n\n    // read address pattern\n    const address = new AtomicString()\n    address.unpack(dataView, initialOffset)\n\n    // read type string\n    const types = new AtomicString()\n    types.unpack(dataView, address.offset)\n\n    if (address.value.length === 0 || address.value[0] !== '/') {\n      throw new Error('OSC Message found malformed or missing address string')\n    }\n\n    if (types.value.length === 0 && types.value[0] !== ',') {\n      throw new Error('OSC Message found malformed or missing type string')\n    }\n\n    let { offset } = types\n    let next\n    let type\n\n    const args = []\n\n    // read message arguments (OSC Atomic Data Types)\n    for (let i = 1; i < types.value.length; i += 1) {\n      type = types.value[i]\n      next = null\n\n      if (type === 'i') {\n        next = new AtomicInt32()\n      } else if (type === 'h') {\n        next = new AtomicInt64()\n      } else if (type === 't') {\n        next = new AtomicUInt64()\n      } else if (type === 'f') {\n        next = new AtomicFloat32()\n      } else if (type === 'd') {\n        next = new AtomicFloat64()\n      } else if (type === 's') {\n        next = new AtomicString()\n      } else if (type === 'b') {\n        next = new AtomicBlob()\n      } else if (type === 'T') {\n        args.push(VALUE_TRUE)\n      } else if (type === 'F') {\n        args.push(VALUE_FALSE)\n      } else if (type === 'N') {\n        args.push(VALUE_NONE)\n      } else if (type === 'I') {\n        args.push(VALUE_INFINITY)\n      } else {\n        throw new Error('OSC Message found unsupported argument type')\n      }\n\n      if (next) {\n        offset = next.unpack(dataView, offset)\n        args.push(next.value)\n      }\n    }\n\n    this.offset = offset\n    this.address = address.value\n    this.types = types.value\n    this.args = args\n\n    return this.offset\n  }\n}\n\n/**\n * An OSC message consists of an OSC Address Pattern followed\n * by an OSC Type Tag String followed by zero or more OSC Arguments\n */\nexport default class Message extends TypedMessage {\n  /**\n   * Create a Message instance\n   * @param {string[]|string} address Address\n   * @param {...MessageArgValue} args OSC Atomic Data Types\n   *\n   * @example\n   * const message = new Message(['test', 'path'], 50, 100.52, 'test')\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   */\n  constructor(address, ...args) {\n    let oscArgs\n    if (args.length > 0) {\n      if (args[0] instanceof Array) {\n        oscArgs = args.shift()\n      }\n    }\n\n    super(address, oscArgs)\n\n    if (args.length > 0) {\n      this.types = args.map((item) => typeTag(item)).join('')\n      this.args = args\n    }\n  }\n\n  /**\n   * Add an OSC Atomic Data Type to the list of elements\n   * @param {MessageArgValue} item\n   */\n  add(item) {\n    super.add(typeTag(item), item)\n  }\n}\n","import EncodeHelper from './common/helpers'\nimport { isArray, isInt } from './common/utils'\n\nimport AtomicInt32 from './atomic/int32'\nimport AtomicString from './atomic/string'\nimport AtomicTimetag from './atomic/timetag'\nimport Message from './message'\n\n/** OSC Bundle string */\nexport const BUNDLE_TAG = '#bundle'\n\n/**\n * An OSC Bundle consist of a Timetag and one or many Bundle Elements.\n * The elements are either OSC Messages or more OSC Bundles\n */\nexport default class Bundle {\n  /**\n   * Create a Bundle instance\n   * @param {...*} args Timetag and elements. See examples for options\n   *\n   * @example\n   * const bundle = new Bundle(new Date() + 500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherBundle = new Bundle([message], Date.now() + 1500)\n   *\n   * @example\n   * const message = new Message('/test/path', 51.2)\n   * const anotherMessage = new Message('/test/message', 'test', 12)\n   * const anotherBundle = new Bundle(message, anotherMessage)\n   */\n  constructor(...args) {\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n    /** @type {AtomicTimetag} timetag */\n    this.timetag = new AtomicTimetag()\n    /** @type {array} bundleElements */\n    this.bundleElements = []\n\n    if (args.length > 0) {\n      // first argument is an Date or js timestamp (number)\n      if (args[0] instanceof Date || isInt(args[0])) {\n        this.timetag = new AtomicTimetag(args[0])\n      } else if (isArray(args[0])) {\n        // first argument is an Array of Bundle elements\n        args[0].forEach((item) => {\n          this.add(item)\n        })\n\n        // second argument is an Date or js timestamp (number)\n        if (args.length > 1 && (args[1] instanceof Date || isInt(args[1]))) {\n          this.timetag = new AtomicTimetag(args[1])\n        }\n      } else {\n        // take all arguments as Bundle elements\n        args.forEach((item) => {\n          this.add(item)\n        })\n      }\n    }\n  }\n\n  /**\n   * Take a JavaScript timestamp to set the Bundle's timetag\n   * @param {number} ms JS timestamp in milliseconds\n   *\n   * @example\n   * const bundle = new Bundle()\n   * bundle.timestamp(Date.now() + 5000) // in 5 seconds\n   */\n  timestamp(ms) {\n    if (!isInt(ms)) {\n      throw new Error('OSC Bundle needs an integer for setting the timestamp')\n    }\n\n    this.timetag = new AtomicTimetag(ms)\n  }\n\n  /**\n   * Add a Message or Bundle to the list of elements\n   * @param {Bundle|Message} item\n   */\n  add(item) {\n    if (!(item instanceof Message || item instanceof Bundle)) {\n      throw new Error('OSC Bundle contains only Messages and Bundles')\n    }\n\n    this.bundleElements.push(item)\n  }\n\n  /**\n   * Interpret the Bundle as packed binary data\n   * @return {Uint8Array} Packed binary data\n   */\n  pack() {\n    const encoder = new EncodeHelper()\n\n    // an OSC Bundle consists of the OSC-string \"#bundle\"\n    encoder.add(new AtomicString(BUNDLE_TAG))\n\n    // followed by an OSC Time Tag\n    if (!this.timetag) {\n      this.timetag = new AtomicTimetag()\n    }\n\n    encoder.add(this.timetag)\n\n    // followed by zero or more OSC Bundle Elements\n    this.bundleElements.forEach((item) => {\n      encoder.add(new AtomicInt32(item.pack().byteLength))\n      encoder.add(item)\n    })\n\n    return encoder.merge()\n  }\n\n  /**\n   * Unpack binary data to read a Bundle\n   * @param {DataView} dataView The DataView holding the binary representation of a Bundle\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Bundle expects an instance of type DataView')\n    }\n\n    // read the beginning bundle string\n    const parentHead = new AtomicString()\n    parentHead.unpack(dataView, initialOffset)\n\n    if (parentHead.value !== BUNDLE_TAG) {\n      throw new Error('OSC Bundle does not contain a valid #bundle head')\n    }\n\n    // read the timetag\n    const timetag = new AtomicTimetag()\n    let offset = timetag.unpack(dataView, parentHead.offset)\n\n    // read the bundle elements\n    this.bundleElements = []\n\n    while (offset < dataView.byteLength) {\n      const head = new AtomicString()\n      const size = new AtomicInt32()\n\n      offset = size.unpack(dataView, offset)\n\n      // check if Packet is a Bundle or a Message\n      let item\n      head.unpack(dataView, offset)\n\n      if (head.value === BUNDLE_TAG) {\n        item = new Bundle()\n      } else {\n        item = new Message()\n      }\n\n      offset = item.unpack(dataView, offset)\n\n      this.bundleElements.push(item)\n    }\n\n    this.offset = offset\n    this.timetag = timetag\n\n    return this.offset\n  }\n}\n","import AtomicString from './atomic/string'\nimport Bundle, { BUNDLE_TAG } from './bundle'\nimport Message from './message'\n\n/**\n * The unit of transmission of OSC is an OSC Packet. The contents\n * of an OSC packet must be either an OSC Message or an OSC Bundle\n */\nexport default class Packet {\n  /**\n   * Create a Packet instance holding a Message or Bundle\n   * @param {Message|Bundle} [value] Initial Packet value\n   */\n  constructor(value) {\n    if (value && !(value instanceof Message || value instanceof Bundle)) {\n      throw new Error('OSC Packet value has to be Message or Bundle')\n    }\n\n    /** @type {Message|Bundle} value */\n    this.value = value\n    /**\n     * @type {number} offset\n     * @private\n     */\n    this.offset = 0\n  }\n\n  /**\n   * Packs the Packet value. This implementation is more like\n   * a wrapper due to OSC specifications, you could also skip the\n   * Packet and directly work with the Message or Bundle instance\n   * @return {Uint8Array} Packed binary data\n   *\n   * @example\n   * const message = new Message('/test/path', 21.5, 'test')\n   * const packet = new Packet(message)\n   * const packetBinary = packet.pack() // then send it via udp etc.\n   *\n   * // or skip the Packet for convenience\n   * const messageBinary = message.pack()\n   */\n  pack() {\n    if (!this.value) {\n      throw new Error('OSC Packet can not be encoded with empty body')\n    }\n\n    return this.value.pack()\n  }\n\n  /**\n   * Unpack binary data from DataView to read Messages or Bundles\n   * @param {DataView} dataView The DataView holding a binary representation of a Packet\n   * @param {number} [initialOffset=0] Offset of DataView before unpacking\n   * @return {number} Offset after unpacking\n   */\n  unpack(dataView, initialOffset = 0) {\n    if (!(dataView instanceof DataView)) {\n      throw new Error('OSC Packet expects an instance of type DataView')\n    }\n\n    if (dataView.byteLength % 4 !== 0) {\n      throw new Error('OSC Packet byteLength has to be a multiple of four')\n    }\n\n    const head = new AtomicString()\n    head.unpack(dataView, initialOffset)\n\n    let item\n\n    // check if Packet is a Bundle or a Message\n    if (head.value === BUNDLE_TAG) {\n      item = new Bundle()\n    } else {\n      item = new Message()\n    }\n\n    item.unpack(dataView, initialOffset)\n\n    this.offset = item.offset\n    this.value = item\n\n    return this.offset\n  }\n}\n","import {\n  dataView,\n  isArray,\n  isFunction,\n  isInt,\n  isString,\n} from './common/utils'\n\nimport {\n  prepareAddress,\n  prepareRegExPattern,\n} from './common/helpers'\n\nimport Bundle from './bundle'\nimport Message from './message'\nimport Packet from './packet'\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  discardLateMessages: false,\n}\n\n/**\n * EventHandler to notify listeners on matching OSC messages and\n * status changes of plugins\n */\nexport default class EventHandler {\n  /**\n   * Create an EventHandler instance\n   * @param {object} options Custom options\n   */\n  constructor(options) {\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = { ...defaultOptions, ...options }\n    /**\n     * @type {array} addressHandlers\n     * @private\n     */\n    this.addressHandlers = []\n    /**\n     * @type {object} eventHandlers\n     * @private\n     */\n    this.eventHandlers = {\n      open: [],\n      error: [],\n      close: [],\n    }\n    /**\n     * @type {number} uuid\n     * @private\n     */\n    this.uuid = 0\n  }\n\n  /**\n   * Internally used method to dispatch OSC Packets. Extracts\n   * given Timetags and dispatches them accordingly\n   * @param {Packet} packet\n   * @param {*} [rinfo] Remote address info\n   * @return {boolean} Success state\n   * @private\n   */\n  dispatch(packet, rinfo) {\n    if (!(packet instanceof Packet)) {\n      throw new Error('OSC EventHander dispatch() accepts only arguments of type Packet')\n    }\n\n    if (!packet.value) {\n      throw new Error('OSC EventHander dispatch() can\\'t read empty Packets')\n    }\n\n    if (packet.value instanceof Bundle) {\n      const bundle = packet.value\n\n      return bundle.bundleElements.forEach((bundleItem) => {\n        if (bundleItem instanceof Bundle) {\n          if (bundle.timetag.value.timestamp() < bundleItem.timetag.value.timestamp()) {\n            throw new Error('OSC Bundle timestamp is older than the timestamp of enclosed Bundles')\n          }\n          return this.dispatch(new Packet(bundleItem))\n        } else if (bundleItem instanceof Message) {\n          const message = bundleItem\n          return this.notify(\n            message.address,\n            message,\n            bundle.timetag.value.timestamp(),\n            rinfo,\n          )\n        }\n\n        throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\n      })\n    } else if (packet.value instanceof Message) {\n      const message = packet.value\n      return this.notify(message.address, message, 0, rinfo)\n    }\n\n    throw new Error('OSC EventHander dispatch() can\\'t dispatch unknown Packet value')\n  }\n\n  /**\n   * Internally used method to invoke listener callbacks. Uses regular\n   * expression pattern matching for OSC addresses\n   * @param {string} name OSC address or event name\n   * @param {*} [data] The data of the event\n   * @param {*} [rinfo] Remote address info\n   * @return {boolean} Success state\n   * @private\n   */\n  call(name, data, rinfo) {\n    let success = false\n\n    // call event handlers\n    if (isString(name) && name in this.eventHandlers) {\n      this.eventHandlers[name].forEach((handler) => {\n        handler.callback(data, rinfo)\n        success = true\n      })\n\n      return success\n    }\n\n    // call address handlers\n    const handlerKeys = Object.keys(this.addressHandlers)\n    const handlers = this.addressHandlers\n\n    handlerKeys.forEach((key) => {\n      let foundMatch = false\n\n      const regex = new RegExp(prepareRegExPattern(prepareAddress(name)), 'g')\n      const test = regex.test(key)\n\n      // found a matching address in our callback handlers\n      if (test && key.length === regex.lastIndex) {\n        foundMatch = true\n      }\n\n      if (!foundMatch) {\n        // try matching address from callback handlers (when given)\n        const reverseRegex = new RegExp(prepareRegExPattern(prepareAddress(key)), 'g')\n        const reverseTest = reverseRegex.test(name)\n\n        if (reverseTest && name.length === reverseRegex.lastIndex) {\n          foundMatch = true\n        }\n      }\n\n      if (foundMatch) {\n        handlers[key].forEach((handler) => {\n          handler.callback(data, rinfo)\n          success = true\n        })\n      }\n    })\n\n    return success\n  }\n\n  /**\n   * Notify the EventHandler of incoming OSC messages or status\n   * changes (*open*, *close*, *error*). Handles OSC address patterns\n   * and executes timed messages. Use binary arrays when\n   * handling directly incoming network data. Packet's or Messages can\n   * also be used\n   * @param {...*} args\n   * The OSC address pattern / event name as string}. For convenience and\n   * Plugin API communication you can also use Message or Packet instances\n   * or ArrayBuffer, Buffer instances (low-level access). The latter will\n   * automatically be unpacked\n   * When using a string you can also pass on data as a second argument\n   * (any type). All regarding listeners will be notified with this data.\n   * As a third argument you can define a javascript timestamp (number or\n   * Date instance) for timed notification of the listeners.\n   * @return {boolean} Success state of notification\n   *\n   * @example\n   * const socket = dgram.createSocket('udp4')\n   * socket.on('message', (message) => {\n   *   this.notify(message)\n   * })\n   *\n   * @example\n   * this.notify('error', error.message)\n   *\n   * @example\n   * const message = new OSC.Message('/test/path', 55)\n   * this.notify(message)\n   *\n   * @example\n   * const message = new OSC.Message('/test/path', 55)\n   * // override timestamp\n   * this.notify(message.address, message, Date.now() + 5000)\n   */\n  notify(...args) {\n    if (args.length === 0) {\n      throw new Error('OSC EventHandler can not be called without any argument')\n    }\n\n    try {\n      // check for incoming dispatchable OSC data\n      if (args[0] instanceof Packet) {\n        return this.dispatch(args[0], args[1])\n      } else if (args[0] instanceof Bundle || args[0] instanceof Message) {\n        return this.dispatch(new Packet(args[0]), args[1])\n      } else if (!isString(args[0])) {\n        const packet = new Packet()\n        packet.unpack(dataView(args[0]))\n        return this.dispatch(packet, args[1])\n      }\n\n      const name = args[0]\n\n      // data argument\n      let data = null\n\n      if (args.length > 1) {\n        data = args[1]\n      }\n\n      // timestamp argument\n      let timestamp = null\n\n      if (args.length > 2) {\n        if (isInt(args[2])) {\n          timestamp = args[2]\n        } else if (args[2] instanceof Date) {\n          timestamp = args[2].getTime()\n        } else {\n          throw new Error('OSC EventHandler timestamp has to be a number or Date')\n        }\n      }\n\n      // remote address info\n      let rinfo = null\n\n      if (args.length >= 3) {\n        rinfo = args[3]\n      }\n\n      // notify now or later\n      if (timestamp) {\n        const now = Date.now()\n\n        // is message outdated?\n        if (now > timestamp) {\n          if (!this.options.discardLateMessages) {\n            return this.call(name, data, rinfo)\n          }\n        }\n\n        // notify later\n        const that = this\n\n        setTimeout(() => {\n          that.call(name, data, rinfo)\n        }, timestamp - now)\n\n        return true\n      }\n\n      return this.call(name, data, rinfo)\n    } catch (error) {\n      this.notify('error', error)\n      return false\n    }\n  }\n\n  /**\n   * Subscribe to a new address or event you want to listen to\n   * @param {string} name The OSC address or event name\n   * @param {function} callback Callback function on notification\n   * @return {number} Subscription identifier (needed to unsubscribe)\n   */\n  on(name, callback) {\n    if (!(isString(name) || isArray(name))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\n    }\n\n    if (!isFunction(callback)) {\n      throw new Error('OSC EventHandler callback has to be a function')\n    }\n\n    // get next id\n    this.uuid += 1\n\n    // prepare handler\n    const handler = {\n      id: this.uuid,\n      callback,\n    }\n\n    // register event listener\n    if (isString(name) && name in this.eventHandlers) {\n      this.eventHandlers[name].push(handler)\n      return this.uuid\n    }\n\n    // register address listener\n    const address = prepareAddress(name)\n\n    if (!(address in this.addressHandlers)) {\n      this.addressHandlers[address] = []\n    }\n\n    this.addressHandlers[address].push(handler)\n\n    return this.uuid\n  }\n\n  /**\n   * Unsubscribe listener from event notification or address handler\n   * @param {string} name The OSC address or event name\n   * @param {number} subscriptionId Subscription id to identify the handler\n   * @return {boolean} Success state\n   */\n  off(name, subscriptionId) {\n    if (!(isString(name) || isArray(name))) {\n      throw new Error('OSC EventHandler accepts only strings or arrays for address patterns')\n    }\n\n    if (!isInt(subscriptionId)) {\n      throw new Error('OSC EventHandler subscription id has to be a number')\n    }\n\n    let key\n    let haystack\n\n    // event or address listener\n    if (isString(name) && name in this.eventHandlers) {\n      key = name\n      haystack = this.eventHandlers\n    } else {\n      key = prepareAddress(name)\n      haystack = this.addressHandlers\n    }\n\n    // remove the entry\n    if (key in haystack) {\n      return haystack[key].some((item, index) => {\n        if (item.id === subscriptionId) {\n          haystack[key].splice(index, 1)\n          return true\n        }\n\n        return false\n      })\n    }\n\n    return false\n  }\n}\n","// /**\n//  @constructor\n//  @abstract\n//  */\n// const Plugin = () => {\n//   if (this.constructor === Plugin) {\n//   }\n// }\n\n// /**\n// @abstract\n// */\n// Plugin.prototype.close = () => {\n//   throw new Error('Abstract method!')\n// }\n\nexport default class Plugin {\n  constructor() {\n    if (this.constructor === Plugin) {\n      throw new Error('Plugin is an abstract class. Please create or use an implementation!')\n    }\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status ID\n   */\n  status() {\n    throw new Error('Abstract method!')\n  }\n\n  /**\n   * Open socket connection. Specifics depend on implementation.\n   * @param {object} [customOptions] Custom options. See implementation specifics.\n   */\n  // eslint-disable-next-line no-unused-vars\n  open(customOptions = {}) {\n    throw new Error('Abstract method!')\n  }\n\n  /**\n   * Close socket connection and anything else used in the implementation.\n   */\n  close() {\n    throw new Error('Abstract method!')\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. Use options here for\n   * custom receiver, otherwise the global options will be taken\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   * @param {object} [customOptions] Custom options. Specifics depend on implementation.\n   */\n  // eslint-disable-next-line no-unused-vars\n  send(binary, customOptions = {}) {\n    throw new Error('Abstract method!')\n  }\n}\n","import dgram from 'dgram'\n\nimport Plugin from './plugin'\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options for open method\n * @private\n */\nconst defaultOpenOptions = {\n  host: 'localhost',\n  port: 41234,\n  exclusive: false,\n}\n\n/**\n * Default options for send method\n * @private\n */\nconst defaultSendOptions = {\n  host: 'localhost',\n  port: 41235,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  type: 'udp4',\n  open: defaultOpenOptions,\n  send: defaultSendOptions,\n}\n\n/**\n * Helper method to merge nested objects\n * @private\n */\nfunction mergeOptions(base, custom) {\n  return {\n    ...defaultOptions,\n    ...base,\n    ...custom,\n    open: { ...defaultOptions.open, ...base.open, ...custom.open },\n    send: { ...defaultOptions.send, ...base.send, ...custom.send },\n  }\n}\n\n/**\n * OSC plugin for simple OSC messaging via udp client\n * and udp server\n */\nexport default class DatagramPlugin extends Plugin {\n  /**\n   * Create an OSC Plugin instance with given options. Defaults to\n   * localhost:41234 for server and localhost:41235 for client messaging\n   * @param {object} [options] Custom options\n   * @param {string} [options.type='udp4'] 'udp4' or 'udp6'\n   * @param {string} [options.open.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [options.open.port=41234] Port of udp server to bind to\n   * @param {boolean} [options.open.exclusive=false] Exclusive flag\n   * @param {string} [options.send.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [options.send.port=41235] Port of udp client for messaging\n   *\n   * @example\n   * const plugin = new OSC.DatagramPlugin({ send: { port: 9912 } })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(options = {}) {\n    super()\n\n    // `dgram` gets replaced with an undefined value in builds targeting\n    // browser environments\n    if (!dgram) {\n      throw new Error('DatagramPlugin can not be used in browser context')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = mergeOptions({}, options)\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = dgram.createSocket(this.options.type)\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    // register events\n    this.socket.on('message', (message, rinfo) => {\n      this.notify(message, rinfo)\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status ID\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Bind a udp socket to a hostname and port\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [customOptions.port=41234] Port of udp server to bind to\n   * @param {boolean} [customOptions.exclusive=false] Exclusive flag\n   */\n  open(customOptions = {}) {\n    const options = { ...this.options.open, ...customOptions }\n    const { port, exclusive } = options\n\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    this.socket.bind({\n      address: options.host,\n      port,\n      exclusive,\n    }, () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    })\n  }\n\n  /**\n   * Close udp socket\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    this.socket.close(() => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. Use options here for\n   * custom port and hostname, otherwise the global options will\n   * be taken\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   * @param {object} [customOptions] Custom options for udp socket\n   * @param {string} [customOptions.host] Hostname of udp client\n   * @param {number} [customOptions.port] Port of udp client\n   */\n  send(binary, customOptions = {}) {\n    const options = { ...this.options.send, ...customOptions }\n    const { port, host } = options\n\n    this.socket.send(Buffer.from(binary), 0, binary.byteLength, port, host)\n  }\n}\n","// This file gets used instead of the `ws` package during rollup builds\n// targeting browser environments.\n/* eslint-disable no-undef */\n/* eslint-disable no-restricted-globals */\nfunction fillWs() {\n  if (typeof WebSocket !== 'undefined') {\n    return WebSocket\n  } else if (typeof MozWebSocket !== 'undefined') {\n    return MozWebSocket\n  } else if (typeof global !== 'undefined') {\n    return global.WebSocket || global.MozWebSocket\n  } else if (typeof window !== 'undefined') {\n    return window.WebSocket || window.MozWebSocket\n  } else if (typeof self !== 'undefined') {\n    return self.WebSocket || self.MozWebSocket\n  }\n  return undefined\n}\n/* eslint-enable no-undef */\n/* eslint-enable no-restricted-globals */\n\nconst ws = fillWs()\n\n/**\n * Do not export server for browser environments.\n * @private\n */\nexport const WebSocketServer = undefined\n\n/**\n * Return WebSocket client for browser environments.\n * @private\n */\nexport default ws\n","import dgram from 'dgram'\nimport { WebSocketServer } from 'ws'\n\nimport Plugin from './plugin'\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  udpServer: {\n    host: 'localhost',\n    port: 41234,\n    exclusive: false,\n  },\n  udpClient: {\n    host: 'localhost',\n    port: 41235,\n  },\n  wsServer: {\n    host: 'localhost',\n    port: 8080,\n  },\n  receiver: 'ws',\n}\n\n/**\n * Helper method to merge nested objects\n * @private\n */\nfunction mergeOptions(base, custom) {\n  return {\n    ...defaultOptions,\n    ...base,\n    ...custom,\n    udpServer: { ...defaultOptions.udpServer, ...base.udpServer, ...custom.udpServer },\n    udpClient: { ...defaultOptions.udpClient, ...base.udpClient, ...custom.udpClient },\n    wsServer: { ...defaultOptions.wsServer, ...base.wsServer, ...custom.wsServer },\n  }\n}\n\n/**\n * OSC plugin for setting up communication between a Websocket\n * client and a udp client with a bridge inbetween\n */\nexport default class BridgePlugin extends Plugin {\n  /**\n   * Create an OSC Bridge instance with given options. Defaults to\n   * localhost:41234 for udp server, localhost:41235 for udp client and\n   * localhost:8080 for Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.udpServer.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [options.udpServer.port=41234] Port of udp server to bind to\n   * @param {boolean} [options.udpServer.exclusive=false] Exclusive flag\n   * @param {string} [options.udpClient.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [options.udpClient.port=41235] Port of udp client for messaging\n   * @param {string} [options.wsServer.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.wsServer.port=8080] Port of Websocket server\n   * @param {http.Server|https.Server} [options.wsServer.server] Use existing Node.js HTTP/S server\n   * @param {string} [options.receiver='ws'] Where messages sent via 'send' method will be\n   * delivered to, 'ws' for Websocket clients, 'udp' for udp client\n   *\n   * @example\n   * const plugin = new OSC.BridgePlugin({ wsServer: { port: 9912 } })\n   * const osc = new OSC({ plugin: plugin })\n   *\n   * @example <caption>Using an existing HTTP server</caption>\n   * const http = require('http')\n   * const httpServer = http.createServer();\n   * const plugin = new OSC.BridgePlugin({ wsServer: { server: httpServer } })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(options = {}) {\n    super()\n\n    // `dgram` and `WebSocketServer` get replaced with an undefined value in\n    // builds targeting browser environments\n    if (!dgram || !WebSocketServer) {\n      throw new Error('BridgePlugin can not be used in browser context')\n    }\n\n    /** @type {object} options\n     * @private\n     */\n    this.options = mergeOptions({}, options)\n\n    /**\n     * @type {object} websocket\n     * @private\n     */\n    this.websocket = null\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = dgram.createSocket('udp4')\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    // register udp events\n    this.socket.on('message', (message) => {\n      this.send(message, { receiver: 'ws' })\n      this.notify(message.buffer)\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status ID\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Bind a udp socket to a hostname and port\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host='localhost'] Hostname of udp server to bind to\n   * @param {number} [customOptions.port=41234] Port of udp server to bind to\n   * @param {boolean} [customOptions.exclusive=false] Exclusive flag\n   */\n  open(customOptions = {}) {\n    const options = mergeOptions(this.options, customOptions)\n\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // bind udp server\n    this.socket.bind({\n      address: options.udpServer.host,\n      port: options.udpServer.port,\n      exclusive: options.udpServer.exclusive,\n    }, () => {\n      let wsServerOptions = {}\n      if (options.wsServer.server) {\n        wsServerOptions.server = options.wsServer.server\n      } else {\n        wsServerOptions = options.wsServer\n      }\n\n      // bind Websocket server\n      this.websocket = new WebSocketServer(wsServerOptions)\n      this.websocket.binaryType = 'arraybuffer'\n\n      // register Websocket events\n      this.websocket.on('listening', () => {\n        this.socketStatus = STATUS.IS_OPEN\n        this.notify('open')\n      })\n\n      this.websocket.on('error', (error) => {\n        this.notify('error', error)\n      })\n\n      this.websocket.on('connection', (client) => {\n        client.on('message', (message, rinfo) => {\n          this.send(message, { receiver: 'udp' })\n          this.notify(new Uint8Array(message), rinfo)\n        })\n      })\n    })\n  }\n\n  /**\n   * Close udp socket and Websocket server\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    // close udp socket\n    this.socket.close(() => {\n      // close Websocket\n      this.websocket.close(() => {\n        this.socketStatus = STATUS.IS_CLOSED\n        this.notify('close')\n      })\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. Use options here for\n   * custom receiver, otherwise the global options will be taken\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.udpClient.host='localhost'] Hostname of udp client for messaging\n   * @param {number} [customOptions.udpClient.port=41235] Port of udp client for messaging\n   * @param {string} [customOptions.receiver='ws'] Messages will be delivered to Websocket ('ws')\n   * clients or udp client ('udp')\n   */\n  send(binary, customOptions = {}) {\n    const options = mergeOptions(this.options, customOptions)\n    const { receiver } = options\n\n    if (receiver === 'udp') {\n      // send data to udp client\n      const data = binary instanceof Buffer ? binary : Buffer.from(binary)\n      this.socket.send(\n        data,\n        0,\n        data.byteLength,\n        options.udpClient.port,\n        options.udpClient.host,\n      )\n    } else if (receiver === 'ws') {\n      // send data to all Websocket clients\n      this.websocket.clients.forEach((client) => {\n        client.send(binary, { binary: true })\n      })\n    } else {\n      throw new Error('BridgePlugin can not send message to unknown receiver')\n    }\n  }\n}\n","import WebSocket from 'ws'\n\nimport Plugin from './plugin'\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  host: 'localhost',\n  port: 8080,\n  secure: false,\n  protocol: [],\n}\n\n/**\n * OSC plugin for a Websocket client running in node or browser context\n */\nexport default class WebsocketClientPlugin extends Plugin {\n  /**\n   * Create an OSC WebsocketClientPlugin instance with given options.\n   * Defaults to *localhost:8080* for connecting to a Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.port=8080] Port of Websocket server\n   * @param {boolean} [options.secure=false] Use wss:// for secure connections\n   * @param {string|string[]} [options.protocol=''] Subprotocol of Websocket server\n   *\n   * @example\n   * const plugin = new OSC.WebsocketClientPlugin({ port: 9912 })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(options) {\n    super()\n\n    if (!WebSocket) {\n      throw new Error('WebsocketClientPlugin can\\'t find a WebSocket class')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = { ...defaultOptions, ...options }\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = null\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status identifier\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Connect to a Websocket server. Defaults to global options\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host] Hostname of Websocket server\n   * @param {number} [customOptions.port] Port of Websocket server\n   * @param {boolean} [customOptions.secure] Use wss:// for secure connections\n   * @param {string|string[]} [options.protocol] Subprotocol of Websocket server\n   */\n  open(customOptions = {}) {\n    const options = { ...this.options, ...customOptions }\n    const {\n      port, host, secure, protocol,\n    } = options\n\n    // close socket when already given\n    if (this.socket) {\n      this.close()\n    }\n\n    // create websocket client\n    const scheme = secure ? 'wss' : 'ws'\n    const rinfo = {\n      address: host,\n      family: scheme,\n      port,\n      size: 0,\n    }\n\n    this.socket = new WebSocket(`${scheme}://${host}:${port}`, protocol)\n    this.socket.binaryType = 'arraybuffer'\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // register events\n    this.socket.onopen = () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    }\n\n    this.socket.onclose = () => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    }\n\n    this.socket.onerror = (error) => {\n      this.notify('error', error)\n    }\n\n    this.socket.onmessage = (message) => {\n      this.notify(message.data, rinfo)\n    }\n  }\n\n  /**\n   * Close Websocket\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n    this.socket.close()\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message to Websocket server\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   */\n  send(binary) {\n    this.socket.send(binary)\n  }\n}\n","import { WebSocketServer } from 'ws'\n\nimport Plugin from './plugin'\n\n/**\n * Status flags\n * @private\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  host: 'localhost',\n  port: 8080,\n}\n\n/**\n * This will import the types for JSDoc/Type declarations without\n * impacting the runtime\n * @typedef {import('http').Server|import('https').Server} Server\n */\n\n/**\n * OSC plugin for a Websocket client running in node or browser context\n */\nexport default class WebsocketServerPlugin extends Plugin {\n  /**\n   * Create an OSC WebsocketServerPlugin instance with given options.\n   * Defaults to *localhost:8080* for the Websocket server\n   * @param {object} [options] Custom options\n   * @param {string} [options.host='localhost'] Hostname of Websocket server\n   * @param {number} [options.port=8080] Port of Websocket server\n   * @param {Server} [options.server] Use existing Node.js HTTP/S server\n   *\n   * @example\n   * const plugin = new OSC.WebsocketServerPlugin({ port: 9912 })\n   * const osc = new OSC({ plugin: plugin })\n   *\n   * osc.open() // start server\n   * @example <caption>Using an existing HTTP server</caption>\n   * const http = require('http')\n   * const httpServer = http.createServer();\n   * const plugin = new OSC.WebsocketServerPlugin({ server: httpServer })\n   * const osc = new OSC({ plugin: plugin })\n   */\n  constructor(options) {\n    super()\n\n    // `WebSocketServer` gets replaced with an undefined value in builds\n    // targeting browser environments\n    if (!WebSocketServer) {\n      throw new Error('WebsocketServerPlugin can not be used in browser context')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = { ...defaultOptions, ...options }\n\n    /**\n     * @type {object} socket\n     * @private\n     */\n    this.socket = null\n    /**\n     * @type {number} socketStatus\n     * @private\n     */\n    this.socketStatus = STATUS.IS_NOT_INITIALIZED\n\n    /**\n     * @type {function} notify\n     * @private\n     */\n    this.notify = () => {}\n  }\n\n  /**\n   * Internal method to hook into osc library's\n   * EventHandler notify method\n   * @param {function} fn Notify callback\n   * @private\n   */\n  registerNotify(fn) {\n    this.notify = fn\n  }\n\n  /**\n   * Returns the current status of the connection\n   * @return {number} Status identifier\n   */\n  status() {\n    return this.socketStatus\n  }\n\n  /**\n   * Start a Websocket server. Defaults to global options\n   * @param {object} [customOptions] Custom options\n   * @param {string} [customOptions.host] Hostname of Websocket server\n   * @param {number} [customOptions.port] Port of Websocket server\n   */\n  open(customOptions = {}) {\n    const options = { ...this.options, ...customOptions }\n    const { port, host } = options\n    const rinfo = {\n      address: host,\n      family: 'wsserver',\n      port,\n      size: 0,\n    }\n\n    // close socket when already given\n    if (this.socket) {\n      this.close()\n    }\n\n    // create websocket server\n    if (options.server) {\n      this.socket = new WebSocketServer({ server: options.server })\n    } else {\n      this.socket = new WebSocketServer({ host, port })\n    }\n\n    this.socket.binaryType = 'arraybuffer'\n    this.socketStatus = STATUS.IS_CONNECTING\n\n    // register events\n    this.socket.on('listening', () => {\n      this.socketStatus = STATUS.IS_OPEN\n      this.notify('open')\n    })\n\n    this.socket.on('error', (error) => {\n      this.notify('error', error)\n    })\n\n    this.socket.on('connection', (client) => {\n      client.on('message', (message) => {\n        this.notify(new Uint8Array(message), rinfo)\n      })\n    })\n  }\n\n  /**\n   * Close Websocket server\n   */\n  close() {\n    this.socketStatus = STATUS.IS_CLOSING\n\n    this.socket.close(() => {\n      this.socketStatus = STATUS.IS_CLOSED\n      this.notify('close')\n    })\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message to Websocket clients\n   * @param {Uint8Array} binary Binary representation of OSC Packet\n   */\n  send(binary) {\n    this.socket.clients.forEach((client) => {\n      client.send(binary, { binary: true })\n    })\n  }\n}\n","import {\n  isFunction,\n  isInt,\n  isObject,\n  isString,\n} from './common/utils'\n\nimport Bundle from './bundle'\nimport EventHandler from './events'\nimport Message, { TypedMessage } from './message'\nimport Packet from './packet'\n\nimport DatagramPlugin from './plugin/dgram'\nimport BridgePlugin from './plugin/bridge'\nimport WebsocketClientPlugin from './plugin/wsclient'\nimport WebsocketServerPlugin from './plugin/wsserver'\nimport Plugin from './plugin/plugin'\n\n/**\n * Default options\n * @private\n */\nconst defaultOptions = {\n  discardLateMessages: false,\n}\n\n/**\n * Status flags\n */\nconst STATUS = {\n  IS_NOT_INITIALIZED: -1,\n  IS_CONNECTING: 0,\n  IS_OPEN: 1,\n  IS_CLOSING: 2,\n  IS_CLOSED: 3,\n}\n\n/**\n * OSC interface to send OSC Packets and listen to status changes and\n * incoming message events. Offers a Plugin API for different network\n * protocols, defaults to a simple Websocket client for OSC communication\n * between a browser js-app and a js-node server\n *\n * @example\n * const osc = new OSC()\n *\n * osc.on('/input/test', message => {\n *   // print incoming OSC message arguments\n *   console.log(message.args)\n * })\n *\n * osc.on('open', () => {\n *   const message = new Message('/test/path', 55.12, 'hello')\n *   osc.send(message)\n * })\n *\n * osc.open({ host: '192.168.178.115', port: 9012 })\n */\nclass OSC {\n  /**\n   * Create an OSC instance with given options\n   * @param {object} [options] Custom options\n   * @param {boolean} [options.discardLateMessages=false] Ignore incoming\n   * messages when given timetag lies in the past\n   * @param {Plugin} [options.plugin=WebsocketClientPlugin] Add a connection plugin\n   * to this interface, defaults to a plugin with Websocket client.\n   * Open README.md for further information on how to handle plugins or\n   * how to write your own with the Plugin API\n   *\n   * @example\n   * const osc = new OSC() // default options with Websocket client\n   *\n   * @example\n   * const osc = new OSC({ discardLateMessages: true })\n   *\n   * @example\n   * const websocketPlugin = new OSC.WebsocketClientPlugin()\n   * const osc = new OSC({ plugin: websocketPlugin })\n   */\n  constructor(options) {\n    if (options && !isObject(options)) {\n      throw new Error('OSC options argument has to be an object.')\n    }\n\n    /**\n     * @type {object} options\n     * @private\n     */\n    this.options = { ...defaultOptions, ...options }\n    // create default plugin with default options\n    if (!this.options.plugin) {\n      this.options.plugin = new WebsocketClientPlugin()\n    }\n    /**\n     * @type {EventHandler} eventHandler\n     * @private\n     */\n    this.eventHandler = new EventHandler({\n      discardLateMessages: this.options.discardLateMessages,\n    })\n\n    // pass EventHandler's notify() to plugin\n    const { eventHandler } = this\n    if (this.options.plugin && this.options.plugin.registerNotify) {\n      this.options.plugin.registerNotify((...args) => eventHandler.notify(...args))\n    }\n  }\n\n  /**\n   * Listen to a status-change event or incoming OSC message with\n   * address pattern matching\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {function} callback Function which is called on notification\n   * @return {number} Subscription id (needed to unsubscribe)\n   *\n   * @example\n   * // will be called when server receives /in!trument/* for example\n   * osc.on('/instrument/1', message => {\n   *   console.log(message)\n   * })\n   *\n   * @example\n   * // will be called for every message since it uses the wildcard symbol\n   * osc.on('*', message => {\n   *   console.log(message)\n   * })\n   *\n   * @example\n   * // will be called on network socket error\n   * osc.on('error', message => {\n   *   console.log(message)\n   * })\n   */\n  on(eventName, callback) {\n    if (!(isString(eventName) && isFunction(callback))) {\n      throw new Error('OSC on() needs event- or address string and callback function')\n    }\n\n    return this.eventHandler.on(eventName, callback)\n  }\n\n  /**\n   * Unsubscribe an event listener\n   * @param {string} eventName Event name or OSC address pattern\n   * @param {number} subscriptionId The subscription id\n   * @return {boolean} Success state\n   *\n   * @example\n   * const listenerId = osc.on('error', message => {\n   *   console.log(message)\n   * })\n   * osc.off('error', listenerId) // unsubscribe from error event\n   */\n  off(eventName, subscriptionId) {\n    if (!(isString(eventName) && isInt(subscriptionId))) {\n      throw new Error('OSC off() needs string and number (subscriptionId) to unsubscribe')\n    }\n\n    return this.eventHandler.off(eventName, subscriptionId)\n  }\n\n  /**\n   * Open network socket with plugin. This method is used by\n   * plugins and is not available without (see Plugin API for more information)\n   * @param {object} [options] Custom global options for plugin instance\n   *\n   * @example\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   */\n  open(options) {\n    if (options && !isObject(options)) {\n      throw new Error('OSC open() options argument needs to be an object')\n    }\n\n    if (!(this.options.plugin && isFunction(this.options.plugin.open))) {\n      throw new Error('OSC Plugin API #open is not implemented!')\n    }\n\n    return this.options.plugin.open(options)\n  }\n\n  /**\n   * Returns the current status of the connection. See *STATUS* for\n   * different possible states. This method is used by plugins\n   * and is not available without (see Plugin API for more information)\n   * @return {number} Status identifier\n   *\n   * @example\n   * import OSC, { STATUS } from 'osc'\n   * const osc = new OSC()\n   * if (osc.status() === STATUS.IS_CONNECTING) {\n   *   // do something\n   * }\n   */\n  status() {\n    if (!(this.options.plugin && isFunction(this.options.plugin.status))) {\n      throw new Error('OSC Plugin API #status is not implemented!')\n    }\n\n    return this.options.plugin.status()\n  }\n\n  /**\n   * Close connection. This method is used by plugins and is not\n   * available without (see Plugin API for more information)\n   */\n  close() {\n    if (!(this.options.plugin && isFunction(this.options.plugin.close))) {\n      throw new Error('OSC Plugin API #close is not implemented!')\n    }\n\n    return this.options.plugin.close()\n  }\n\n  /**\n   * Send an OSC Packet, Bundle or Message. This method is used by plugins\n   * and is not available without (see Plugin API for more information)\n   * @param {Packet|Bundle|Message|TypedMessage} packet OSC Packet, Bundle or Message instance\n   * @param {object} [options] Custom options\n   *\n   * @example\n   * const osc = new OSC({ plugin: new OSC.DatagramPlugin() })\n   * osc.open({ host: '127.0.0.1', port: 8080 })\n   *\n   * const message = new OSC.Message('/test/path', 55.1, 57)\n   * osc.send(message)\n   *\n   * // send message again to custom address\n   * osc.send(message, { host: '192.168.178.115', port: 9001 })\n   */\n  send(packet, options) {\n    if (!(this.options.plugin && isFunction(this.options.plugin.send))) {\n      throw new Error('OSC Plugin API #send is not implemented!')\n    }\n\n    if (!(packet instanceof TypedMessage\n        || packet instanceof Message\n        || packet instanceof Bundle\n        || packet instanceof Packet)\n    ) {\n      throw new Error('OSC send() needs Messages, Bundles or Packets')\n    }\n\n    if (options && !isObject(options)) {\n      throw new Error('OSC send() options argument has to be an object')\n    }\n\n    return this.options.plugin.send(packet.pack(), options)\n  }\n}\n\n// expose status flags\nOSC.STATUS = STATUS\n\n// expose OSC classes\nOSC.Packet = Packet\nOSC.Bundle = Bundle\nOSC.Message = Message\nOSC.TypedMessage = TypedMessage\n\n// expose plugins\nOSC.Plugin = Plugin\nOSC.DatagramPlugin = DatagramPlugin\nOSC.WebsocketClientPlugin = WebsocketClientPlugin\nOSC.WebsocketServerPlugin = WebsocketServerPlugin\nOSC.BridgePlugin = BridgePlugin\n\nexport default OSC\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","module.exports = new __parcel__URL__(\"sw.js\").toString();"],"names":["$eeb0961446aae8e3$export$d622b2ad8d90c771","$eeb0961446aae8e3$export$6100ba28696e12de","$7221566bd4d49f44$export$aafa59e2e03f2942","$7221566bd4d49f44$export$68d8715fc104d294","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$18c11f3350a906ea$export$6503ec6e8aabbaf","set","v","enumerable","configurable","$18c11f3350a906ea$var$mapping","Map","baseUrl","manifest","i","length","path","URL","url","toString","JSON","parse","$dddc8561b083d642$exports","b64","tmp","lens","$eeb0961446aae8e3$var$getLens","len","validLen","indexOf","placeHoldersLen","arr","$eeb0961446aae8e3$var$Arr","curByte","$eeb0961446aae8e3$var$revLookup","charCodeAt","uint8","extraBytes","parts","len2","push","$eeb0961446aae8e3$var$encodeChunk","start","end","output","$eeb0961446aae8e3$var$lookup","num","join","Uint8Array","Array","$eeb0961446aae8e3$var$code","$eeb0961446aae8e3$var$i","$eeb0961446aae8e3$var$len","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Math","pow","value","c","rt","isNaN","abs","Infinity","floor","log","LN2","$51861dfc7ca9d588$var$customInspectSymbol","Symbol","$51861dfc7ca9d588$var$createBuffer","RangeError","buf","setPrototypeOf","$51861dfc7ca9d588$var$Buffer","prototype","arg","encodingOrOffset","TypeError","$51861dfc7ca9d588$var$allocUnsafe","$51861dfc7ca9d588$var$from","$51861dfc7ca9d588$var$fromString","string","encoding","isEncoding","$51861dfc7ca9d588$var$byteLength","actual","write","slice","ArrayBuffer","isView","$51861dfc7ca9d588$var$fromArrayView","arrayView","$51861dfc7ca9d588$var$isInstance","copy","$51861dfc7ca9d588$var$fromArrayBuffer","byteOffset","byteLength","$51861dfc7ca9d588$var$fromArrayLike","SharedArrayBuffer","valueOf","from","b","$51861dfc7ca9d588$var$fromObject","obj","isBuffer","$51861dfc7ca9d588$var$checked","undefined","type","isArray","data","toPrimitive","$51861dfc7ca9d588$var$assertSize","size","array","mustMatch","arguments","loweredCase","$51861dfc7ca9d588$var$utf8ToBytes","$51861dfc7ca9d588$var$base64ToBytes","toLowerCase","$51861dfc7ca9d588$var$slowToString","$51861dfc7ca9d588$var$hexSlice","out","$51861dfc7ca9d588$var$hexSliceLookupTable","$51861dfc7ca9d588$var$utf8Slice","$51861dfc7ca9d588$var$asciiSlice","ret","min","String","fromCharCode","$51861dfc7ca9d588$var$latin1Slice","$51861dfc7ca9d588$var$utf16leSlice","bytes","res","$51861dfc7ca9d588$var$swap","n","$51861dfc7ca9d588$var$bidirectionalIndexOf","val","dir","$51861dfc7ca9d588$var$arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","read","readUInt16BE","foundIndex","found","j","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","$51861dfc7ca9d588$var$decodeCodePointsArray","codePoints","apply","$51861dfc7ca9d588$var$checkOffset","ext","$51861dfc7ca9d588$var$checkInt","max","$51861dfc7ca9d588$var$wrtBigUInt64LE","$51861dfc7ca9d588$var$checkIntBI","lo","Number","BigInt","hi","$51861dfc7ca9d588$var$wrtBigUInt64BE","$51861dfc7ca9d588$var$checkIEEE754","$51861dfc7ca9d588$var$writeFloat","littleEndian","noAssert","$51861dfc7ca9d588$var$writeDouble","TYPED_ARRAY_SUPPORT","$51861dfc7ca9d588$var$typedArraySupport","proto","foo","console","error","poolSize","alloc","fill","allocUnsafe","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","toLocaleString","equals","inspect","str","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","remaining","$51861dfc7ca9d588$var$hexWrite","strLen","parsed","parseInt","substr","$51861dfc7ca9d588$var$blitBuffer","$51861dfc7ca9d588$var$asciiToBytes","byteArray","$51861dfc7ca9d588$var$utf16leToBytes","units","toJSON","_arr","newBuf","subarray","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUInt32LE","readUint32BE","readUInt32BE","readBigUInt64LE","$51861dfc7ca9d588$var$defineBigIntMethod","$51861dfc7ca9d588$var$validateNumber","first","last","$51861dfc7ca9d588$var$boundsError","readBigUInt64BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","maxBytes","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","$51861dfc7ca9d588$var$errors","$51861dfc7ca9d588$var$E","sym","getMessage","Base","constructor","writable","name","stack","message","$51861dfc7ca9d588$var$addNumericalSeparator","range","ERR_OUT_OF_RANGE","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","$51861dfc7ca9d588$var$INVALID_BASE64_RE","leadSurrogate","$51861dfc7ca9d588$var$base64clean","split","src","dst","alphabet","table","i16","fn","$51861dfc7ca9d588$var$BufferBigIntNotDefined","t","r","f","ReferenceError","Reflect","construct","Boolean","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","forEach","o","getOwnPropertyDescriptors","defineProperties","key","create","l","getPrototypeOf","bind","__proto__","p","h","hasOwnProperty","w","k","S","O","A","window","D","B","M","pack","DataView","T","H","N","getUint8","L","$dddc8561b083d642$require$Buffer","TextDecoder","decode","Int8Array","U","seconds","fractions","round","W","V","_","Date","now","timestamp","E","getTime","setInt32","getUint32","F","getInt32","R","z","G","Z","q","asIntN","J","K","asUintN","$","tt","address","types","args","add","merge","unpack","u","et","shift","map","nt","timetag","bundleElements","ot","it","discardLateMessages","st","options","addressHandlers","eventHandlers","open","close","uuid","dispatch","notify","callback","RegExp","test","lastIndex","setTimeout","some","splice","at","ht","socketStatus","port","exclusive","socket","host","send","pt","WebSocket","MozWebSocket","self","dt","kt","udpServer","udpClient","wsServer","receiver","bt","mt","server","websocket","binaryType","on","clients","binary","At","secure","protocol","It","family","onopen","onclose","onerror","onmessage","xt","Tt","Ht","plugin","eventHandler","registerNotify","off","status","STATUS","IS_NOT_INITIALIZED","IS_CONNECTING","IS_OPEN","IS_CLOSING","IS_CLOSED","Packet","Bundle","Message","TypedMessage","Plugin","DatagramPlugin","WebsocketClientPlugin","WebsocketServerPlugin","BridgePlugin","$e73bf42412feb220$var$plugin","$e73bf42412feb220$var$osc","$e73bf42412feb220$var$createKnobs","numKnobs","$e73bf42412feb220$var$removeKnobs","knobsDiv","document","querySelector","remove","createElement","className","knob","setAttribute","appendChild","app","getElementById","addEventListener","event","parseFloat","padStart","$5cccb5591bb3b1ca$exports","$e73bf42412feb220$var$registerSW","navigator","serviceWorker","$e73bf42412feb220$var$connect","ip","$e73bf42412feb220$var$ipElement","onbeforeunload","isInt","isNumber","isString","isBoolean","isInfinity","isObject","isFunction","isBlob","isDate","isUndefined","isNull","pad","hasProperty","global","dataView","typeTag","item","prepareAddress","prepareRegExPattern","EncodeHelper","_createClass","_classCallCheck","this","result","Atomic","method","initialOffset","AtomicInt32","_Atomic","_callSuper","_inherits","_get","_getPrototypeOf","STR_ENCODING","charCodesToString","charCodes","Buffer","AtomicString","terminated","charcode","SECONDS_70_YEARS","TWO_POWER_32","Timetag","milliseconds","rounded","AtomicTimetag","_this$value","AtomicBlob","AtomicFloat32","AtomicFloat64","MAX_INT64","MIN_INT64","AtomicInt64","MAX_UINT64","AtomicUInt64","VALUE_TRUE","VALUE_FALSE","VALUE_NONE","VALUE_INFINITY","_this","_this2","encoder","Helper","argument","index","next","_TypedMessage","_this3","oscArgs","_len","_key","BUNDLE_TAG","ms","parentHead","head","defaultOptions","EventHandler","_objectSpread","packet","rinfo","bundle","bundleItem","success","handler","handlerKeys","handlers","foundMatch","regex","reverseRegex","that","subscriptionId","haystack","_Plugin","customOptions","ws","WebSocketServer","mergeOptions","base","custom","wsServerOptions","client","scheme","OSC","eventName"],"version":3,"file":"index.e121266c.js.map"}